[
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "NearestNeighbors",
        "importPath": "sklearn.neighbors",
        "description": "sklearn.neighbors",
        "isExtraImport": true,
        "detail": "sklearn.neighbors",
        "documentation": {}
    },
    {
        "label": "NearestNeighbors",
        "importPath": "sklearn.neighbors",
        "description": "sklearn.neighbors",
        "isExtraImport": true,
        "detail": "sklearn.neighbors",
        "documentation": {}
    },
    {
        "label": "OneHotEncoder",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "StandardScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "OneHotEncoder",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "LabelEncoder",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "StandardScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "MinMaxScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "StandardScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "ColumnTransformer",
        "importPath": "sklearn.compose",
        "description": "sklearn.compose",
        "isExtraImport": true,
        "detail": "sklearn.compose",
        "documentation": {}
    },
    {
        "label": "Pipeline",
        "importPath": "sklearn.pipeline",
        "description": "sklearn.pipeline",
        "isExtraImport": true,
        "detail": "sklearn.pipeline",
        "documentation": {}
    },
    {
        "label": "make_pipeline",
        "importPath": "sklearn.pipeline",
        "description": "sklearn.pipeline",
        "isExtraImport": true,
        "detail": "sklearn.pipeline",
        "documentation": {}
    },
    {
        "label": "cosine_similarity",
        "importPath": "sklearn.metrics.pairwise",
        "description": "sklearn.metrics.pairwise",
        "isExtraImport": true,
        "detail": "sklearn.metrics.pairwise",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "Librarian",
        "importPath": "users",
        "description": "users",
        "isExtraImport": true,
        "detail": "users",
        "documentation": {}
    },
    {
        "label": "Loaner",
        "importPath": "users",
        "description": "users",
        "isExtraImport": true,
        "detail": "users",
        "documentation": {}
    },
    {
        "label": "seaborn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "seaborn",
        "description": "seaborn",
        "detail": "seaborn",
        "documentation": {}
    },
    {
        "label": "tensorflow",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tensorflow",
        "description": "tensorflow",
        "detail": "tensorflow",
        "documentation": {}
    },
    {
        "label": "layers",
        "importPath": "tensorflow.keras",
        "description": "tensorflow.keras",
        "isExtraImport": true,
        "detail": "tensorflow.keras",
        "documentation": {}
    },
    {
        "label": "models",
        "importPath": "tensorflow.keras",
        "description": "tensorflow.keras",
        "isExtraImport": true,
        "detail": "tensorflow.keras",
        "documentation": {}
    },
    {
        "label": "layers",
        "importPath": "tensorflow.keras",
        "description": "tensorflow.keras",
        "isExtraImport": true,
        "detail": "tensorflow.keras",
        "documentation": {}
    },
    {
        "label": "models",
        "importPath": "tensorflow.keras",
        "description": "tensorflow.keras",
        "isExtraImport": true,
        "detail": "tensorflow.keras",
        "documentation": {}
    },
    {
        "label": "cifar10",
        "importPath": "tensorflow.keras.datasets",
        "description": "tensorflow.keras.datasets",
        "isExtraImport": true,
        "detail": "tensorflow.keras.datasets",
        "documentation": {}
    },
    {
        "label": "mnist",
        "importPath": "tensorflow.keras.datasets",
        "description": "tensorflow.keras.datasets",
        "isExtraImport": true,
        "detail": "tensorflow.keras.datasets",
        "documentation": {}
    },
    {
        "label": "ResNet50",
        "importPath": "tensorflow.keras.applications",
        "description": "tensorflow.keras.applications",
        "isExtraImport": true,
        "detail": "tensorflow.keras.applications",
        "documentation": {}
    },
    {
        "label": "Dense",
        "importPath": "tensorflow.keras.layers",
        "description": "tensorflow.keras.layers",
        "isExtraImport": true,
        "detail": "tensorflow.keras.layers",
        "documentation": {}
    },
    {
        "label": "Flatten",
        "importPath": "tensorflow.keras.layers",
        "description": "tensorflow.keras.layers",
        "isExtraImport": true,
        "detail": "tensorflow.keras.layers",
        "documentation": {}
    },
    {
        "label": "Model",
        "importPath": "tensorflow.keras.models",
        "description": "tensorflow.keras.models",
        "isExtraImport": true,
        "detail": "tensorflow.keras.models",
        "documentation": {}
    },
    {
        "label": "load_model",
        "importPath": "tensorflow.keras.models",
        "description": "tensorflow.keras.models",
        "isExtraImport": true,
        "detail": "tensorflow.keras.models",
        "documentation": {}
    },
    {
        "label": "ImageDataGenerator",
        "importPath": "tensorflow.keras.preprocessing.image",
        "description": "tensorflow.keras.preprocessing.image",
        "isExtraImport": true,
        "detail": "tensorflow.keras.preprocessing.image",
        "documentation": {}
    },
    {
        "label": "train_test_split",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "train_test_split",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "train_test_split",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "nltk",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "nltk",
        "description": "nltk",
        "detail": "nltk",
        "documentation": {}
    },
    {
        "label": "TfidfVectorizer",
        "importPath": "sklearn.feature_extraction.text",
        "description": "sklearn.feature_extraction.text",
        "isExtraImport": true,
        "detail": "sklearn.feature_extraction.text",
        "documentation": {}
    },
    {
        "label": "MultinomialNB",
        "importPath": "sklearn.naive_bayes",
        "description": "sklearn.naive_bayes",
        "isExtraImport": true,
        "detail": "sklearn.naive_bayes",
        "documentation": {}
    },
    {
        "label": "accuracy_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "accuracy_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "stopwords",
        "importPath": "nltk.corpus",
        "description": "nltk.corpus",
        "isExtraImport": true,
        "detail": "nltk.corpus",
        "documentation": {}
    },
    {
        "label": "LogisticRegression",
        "importPath": "sklearn.linear_model",
        "description": "sklearn.linear_model",
        "isExtraImport": true,
        "detail": "sklearn.linear_model",
        "documentation": {}
    },
    {
        "label": "KMeans",
        "importPath": "sklearn.cluster",
        "description": "sklearn.cluster",
        "isExtraImport": true,
        "detail": "sklearn.cluster",
        "documentation": {}
    },
    {
        "label": "KMeans",
        "importPath": "sklearn.cluster",
        "description": "sklearn.cluster",
        "isExtraImport": true,
        "detail": "sklearn.cluster",
        "documentation": {}
    },
    {
        "label": "DBSCAN",
        "importPath": "sklearn.cluster",
        "description": "sklearn.cluster",
        "isExtraImport": true,
        "detail": "sklearn.cluster",
        "documentation": {}
    },
    {
        "label": "make_blobs",
        "importPath": "sklearn.datasets",
        "description": "sklearn.datasets",
        "isExtraImport": true,
        "detail": "sklearn.datasets",
        "documentation": {}
    },
    {
        "label": "load_digits",
        "importPath": "sklearn.datasets",
        "description": "sklearn.datasets",
        "isExtraImport": true,
        "detail": "sklearn.datasets",
        "documentation": {}
    },
    {
        "label": "gymnasium",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gymnasium",
        "description": "gymnasium",
        "detail": "gymnasium",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "TSNE",
        "importPath": "sklearn.manifold",
        "description": "sklearn.manifold",
        "isExtraImport": true,
        "detail": "sklearn.manifold",
        "documentation": {}
    },
    {
        "label": "GaussianMixture",
        "importPath": "sklearn.mixture",
        "description": "sklearn.mixture",
        "isExtraImport": true,
        "detail": "sklearn.mixture",
        "documentation": {}
    },
    {
        "label": "apriori",
        "importPath": "mlxtend.frequent_patterns",
        "description": "mlxtend.frequent_patterns",
        "isExtraImport": true,
        "detail": "mlxtend.frequent_patterns",
        "documentation": {}
    },
    {
        "label": "association_rules",
        "importPath": "mlxtend.frequent_patterns",
        "description": "mlxtend.frequent_patterns",
        "isExtraImport": true,
        "detail": "mlxtend.frequent_patterns",
        "documentation": {}
    },
    {
        "label": "dendrogram",
        "importPath": "scipy.cluster.hierarchy",
        "description": "scipy.cluster.hierarchy",
        "isExtraImport": true,
        "detail": "scipy.cluster.hierarchy",
        "documentation": {}
    },
    {
        "label": "linkage",
        "importPath": "scipy.cluster.hierarchy",
        "description": "scipy.cluster.hierarchy",
        "isExtraImport": true,
        "detail": "scipy.cluster.hierarchy",
        "documentation": {}
    },
    {
        "label": "fcluster",
        "importPath": "scipy.cluster.hierarchy",
        "description": "scipy.cluster.hierarchy",
        "isExtraImport": true,
        "detail": "scipy.cluster.hierarchy",
        "documentation": {}
    },
    {
        "label": "PCA",
        "importPath": "sklearn.decomposition",
        "description": "sklearn.decomposition",
        "isExtraImport": true,
        "detail": "sklearn.decomposition",
        "documentation": {}
    },
    {
        "label": "PCA",
        "importPath": "sklearn.decomposition",
        "description": "sklearn.decomposition",
        "isExtraImport": true,
        "detail": "sklearn.decomposition",
        "documentation": {}
    },
    {
        "label": "joblib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "joblib",
        "description": "joblib",
        "detail": "joblib",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "h5py",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "h5py",
        "description": "h5py",
        "detail": "h5py",
        "documentation": {}
    },
    {
        "label": "BookData",
        "kind": 6,
        "importPath": "projects-example.supervides-learning.advanced-ref",
        "description": "projects-example.supervides-learning.advanced-ref",
        "peekOfCode": "class BookData:\n    def __init__(self):\n        self.books_df = None\n        self.feature_matrix = None\n        self.preprocessor = None\n    def load_data(self):\n        self.books_df = pd.DataFrame({\n            'title': [\n                'The Hobbit', 'Dune', 'Mistborn', 'Neuromancer', 'The Name of the Wind',\n                'The Way of Kings', 'A Game of Thrones', 'The Colour of Magic', 'Assassin\\'s Apprentice',",
        "detail": "projects-example.supervides-learning.advanced-ref",
        "documentation": {}
    },
    {
        "label": "UserData",
        "kind": 6,
        "importPath": "projects-example.supervides-learning.advanced-ref",
        "description": "projects-example.supervides-learning.advanced-ref",
        "peekOfCode": "class UserData:\n    def __init__(self):\n        self.user_preferences = {}\n    def get_user_input(self):\n        print(\"Please rate your interest in the following subgenres (1-5):\")\n        subgenres = ['High Fantasy', 'Sci-Fi', 'Epic Fantasy', 'Cyberpunk', 'Comic Fantasy', 'Grimdark Fantasy']\n        for subgenre in subgenres:\n            while True:\n                try:\n                    rating = int(input(f\"{subgenre}: \"))",
        "detail": "projects-example.supervides-learning.advanced-ref",
        "documentation": {}
    },
    {
        "label": "RecommendationModel",
        "kind": 6,
        "importPath": "projects-example.supervides-learning.advanced-ref",
        "description": "projects-example.supervides-learning.advanced-ref",
        "peekOfCode": "class RecommendationModel:\n    def __init__(self, book_data):\n        self.book_data = book_data\n        self.model = None\n    def train_model(self):\n        # Use cosine similarity instead of Euclidean distance\n        self.model = cosine_similarity(self.book_data.feature_matrix)\n        print(\"Model trained successfully.\")\n    def get_recommendations(self, user_preferences):\n        # Create a user vector based on their preferences",
        "detail": "projects-example.supervides-learning.advanced-ref",
        "documentation": {}
    },
    {
        "label": "UserInterface",
        "kind": 6,
        "importPath": "projects-example.supervides-learning.advanced-ref",
        "description": "projects-example.supervides-learning.advanced-ref",
        "peekOfCode": "class UserInterface:\n    def __init__(self, recommendation_model, user_data):\n        self.recommendation_model = recommendation_model\n        self.user_data = user_data\n    def run(self):\n        print(\"Welcome to the Advanced Fantasy Book Recommender!\")\n        self.user_data.get_user_input()\n        recommendations = self.recommendation_model.get_recommendations(self.user_data.user_preferences)\n        print(\"\\nBased on your preferences, we recommend:\")\n        for i, book in enumerate(recommendations, 1):",
        "detail": "projects-example.supervides-learning.advanced-ref",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "projects-example.supervides-learning.advanced-ref",
        "description": "projects-example.supervides-learning.advanced-ref",
        "peekOfCode": "def main():\n    # Initialize components\n    book_data = BookData()\n    user_data = UserData()\n    # Load and preprocess data\n    book_data.load_data()\n    book_data.preprocess_data()\n    # Initialize and train the model\n    recommendation_model = RecommendationModel(book_data)\n    recommendation_model.train_model()",
        "detail": "projects-example.supervides-learning.advanced-ref",
        "documentation": {}
    },
    {
        "label": "BookData",
        "kind": 6,
        "importPath": "projects-example.supervides-learning.MVP-ref",
        "description": "projects-example.supervides-learning.MVP-ref",
        "peekOfCode": "class BookData:\n    def __init__(self):\n        self.books_df = None\n        self.feature_matrix = None\n        self.encoder = None\n    def load_data(self):\n        # Ska egentligen ladda in data från databas med API, eller en fil\n        # Till vår prototyp börjar vi med att skapa eget litet dataset\n        self.books_df = pd.DataFrame({\n            'title': ['The Hobbit', 'Dune', 'Mistborn', 'Neuromancer', 'The Name of the Wind'],",
        "detail": "projects-example.supervides-learning.MVP-ref",
        "documentation": {}
    },
    {
        "label": "UserData",
        "kind": 6,
        "importPath": "projects-example.supervides-learning.MVP-ref",
        "description": "projects-example.supervides-learning.MVP-ref",
        "peekOfCode": "class UserData:\n    def __init__(self):\n        # Lagrar användarens preferenser. Implementeras i nästa iteration.\n        self.user_preferences = {}\n    def get_user_input(self):\n        # Just nu frågar vi bara efter en favorit-bok.\n        favorite_book = input(\"Enter the title of a fantasy book you enjoy: \")\n        return favorite_book\nclass RecommendationModel:\n    def __init__(self, book_data):",
        "detail": "projects-example.supervides-learning.MVP-ref",
        "documentation": {}
    },
    {
        "label": "RecommendationModel",
        "kind": 6,
        "importPath": "projects-example.supervides-learning.MVP-ref",
        "description": "projects-example.supervides-learning.MVP-ref",
        "peekOfCode": "class RecommendationModel:\n    def __init__(self, book_data):\n        self.book_data = book_data\n        self.model = None\n    def train_model(self):\n        # Initiera och träna modellen\n        self.model = NearestNeighbors(n_neighbors=3, metric='euclidean')\n        self.model.fit(self.book_data.feature_matrix)\n        print(\"Model trained successfully.\")\n    def get_recommendations(self, book_title):",
        "detail": "projects-example.supervides-learning.MVP-ref",
        "documentation": {}
    },
    {
        "label": "UserInterface",
        "kind": 6,
        "importPath": "projects-example.supervides-learning.MVP-ref",
        "description": "projects-example.supervides-learning.MVP-ref",
        "peekOfCode": "class UserInterface:\n    def __init__(self, recommendation_model, user_data):\n        self.recommendation_model = recommendation_model\n        self.user_data = user_data\n    def run(self):\n        print(\"Welcome to the Fantasy Book Recommender!\")\n        favorite_book = self.user_data.get_user_input()\n        recommendations, explanations = self.recommendation_model.get_recommendations(favorite_book)\n        print(\"\\nBased on your favorite book, we recommend:\")\n        for book, explanation in zip(recommendations, explanations):",
        "detail": "projects-example.supervides-learning.MVP-ref",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "projects-example.supervides-learning.MVP-ref",
        "description": "projects-example.supervides-learning.MVP-ref",
        "peekOfCode": "def main():\n    # Initiera komponenter\n    book_data = BookData()\n    user_data = UserData()\n    # Ladda in och preprocessa data\n    book_data.load_data()\n    book_data.preprocess_data()\n    # Initiera och träna modellen\n    recommendation_model = RecommendationModel(book_data)\n    recommendation_model.train_model()",
        "detail": "projects-example.supervides-learning.MVP-ref",
        "documentation": {}
    },
    {
        "label": "greet",
        "kind": 2,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "def greet(name):\n    #print(f\"Hello, {name}\")\n    return f\"Hello, {name}!\"\ndef squared(x):\n    return x**2\ngreeting = greet(\"Calle\")\nprint(greeting)\na = 3\na_squared = squared(a)\nprint(f\"{a} squared is: {a_squared}\")",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "squared",
        "kind": 2,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "def squared(x):\n    return x**2\ngreeting = greet(\"Calle\")\nprint(greeting)\na = 3\na_squared = squared(a)\nprint(f\"{a} squared is: {a_squared}\")\n# Enumerate\nfor index, number in enumerate(my_numbers): # enumare() parar ihop varje element i listan med ett index\n    number_squared = squared(number)",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "random_int",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "random_int = random.randint(0,5)\nprint(random_int)\n'''\nmulti-\nline\ncomment\n'''\n# 1. Basic syntrax, kommentarer, printing\nprint(\"Hej, klassen!\") # Printa i Python\n# 2. Variabler och datatyper",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "x = 30               # int\ny = 3.14            # float\nname = \"Calle\"     # string\nis_fun = True       # boolean\n# 3. Type checking, typkonverterting\nprint(type(x))\nz = str(x)\nprint(type(z))\na = \"10\"\nb = int(a) + 1",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "y = 3.14            # float\nname = \"Calle\"     # string\nis_fun = True       # boolean\n# 3. Type checking, typkonverterting\nprint(type(x))\nz = str(x)\nprint(type(z))\na = \"10\"\nb = int(a) + 1\nb += 1      # Samma som b = b + 1",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "name",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "name = \"Calle\"     # string\nis_fun = True       # boolean\n# 3. Type checking, typkonverterting\nprint(type(x))\nz = str(x)\nprint(type(z))\na = \"10\"\nb = int(a) + 1\nb += 1      # Samma som b = b + 1\nprint(b)",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "is_fun",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "is_fun = True       # boolean\n# 3. Type checking, typkonverterting\nprint(type(x))\nz = str(x)\nprint(type(z))\na = \"10\"\nb = int(a) + 1\nb += 1      # Samma som b = b + 1\nprint(b)\n# 4 string operations",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "z",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "z = str(x)\nprint(type(z))\na = \"10\"\nb = int(a) + 1\nb += 1      # Samma som b = b + 1\nprint(b)\n# 4 string operations\nprint(len(name))\nprint(name.upper())\nprint(name.lower())",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "a = \"10\"\nb = int(a) + 1\nb += 1      # Samma som b = b + 1\nprint(b)\n# 4 string operations\nprint(len(name))\nprint(name.upper())\nprint(name.lower())\nprint(\"  string with spaces  \".strip())\nmy_sentence_string = \"a string with multiple words\"",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "b = int(a) + 1\nb += 1      # Samma som b = b + 1\nprint(b)\n# 4 string operations\nprint(len(name))\nprint(name.upper())\nprint(name.lower())\nprint(\"  string with spaces  \".strip())\nmy_sentence_string = \"a string with multiple words\"\nstring_list = my_sentence_string.split(\" \")",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "my_sentence_string",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "my_sentence_string = \"a string with multiple words\"\nstring_list = my_sentence_string.split(\" \")\nprint(string_list)\n# 5 string formatting\nprint(f\"My name is {name} and I'm {x} years old\")\nprint(\"Pi is approximately {:.2f}\".format(y))\n# 6 Lists\nfruits = [\"apple\", \"banana\", \"cherry\", \"apple\"]\nfruits.append(\"date\")\nfruits.insert(1, \"strawberry\")",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "string_list",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "string_list = my_sentence_string.split(\" \")\nprint(string_list)\n# 5 string formatting\nprint(f\"My name is {name} and I'm {x} years old\")\nprint(\"Pi is approximately {:.2f}\".format(y))\n# 6 Lists\nfruits = [\"apple\", \"banana\", \"cherry\", \"apple\"]\nfruits.append(\"date\")\nfruits.insert(1, \"strawberry\")\nprint(fruits[2])",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "fruits",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "fruits = [\"apple\", \"banana\", \"cherry\", \"apple\"]\nfruits.append(\"date\")\nfruits.insert(1, \"strawberry\")\nprint(fruits[2])\nprint(fruits)\nfruits_string = \", \".join(fruits)\n# 7 Dictionaries\nperson_dict1 = { \"name\":\"Alice\", \"age\":30, \"city\":\"New York\" }\nprint(person_dict1[\"name\"])\nperson_dict1[\"job\"] = \"Developer\"",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "fruits_string",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "fruits_string = \", \".join(fruits)\n# 7 Dictionaries\nperson_dict1 = { \"name\":\"Alice\", \"age\":30, \"city\":\"New York\" }\nprint(person_dict1[\"name\"])\nperson_dict1[\"job\"] = \"Developer\"\nprint(person_dict1[\"job\"])\nperson_dict2 = { \"name\":\"Calle\", \"age\":31, \"city\":\"Stockholm\", \"job\":\"Teacher\" }\nperson_list = [] # =list()\nperson_list.append(person_dict1)\nperson_list.append(person_dict2)",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "person_dict1",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "person_dict1 = { \"name\":\"Alice\", \"age\":30, \"city\":\"New York\" }\nprint(person_dict1[\"name\"])\nperson_dict1[\"job\"] = \"Developer\"\nprint(person_dict1[\"job\"])\nperson_dict2 = { \"name\":\"Calle\", \"age\":31, \"city\":\"Stockholm\", \"job\":\"Teacher\" }\nperson_list = [] # =list()\nperson_list.append(person_dict1)\nperson_list.append(person_dict2)\nprint(person_list)\n# 8 Sets",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "person_dict1[\"job\"]",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "person_dict1[\"job\"] = \"Developer\"\nprint(person_dict1[\"job\"])\nperson_dict2 = { \"name\":\"Calle\", \"age\":31, \"city\":\"Stockholm\", \"job\":\"Teacher\" }\nperson_list = [] # =list()\nperson_list.append(person_dict1)\nperson_list.append(person_dict2)\nprint(person_list)\n# 8 Sets\nunique_numbers = {1, 2, 3, 4, 5, 5, 5}\nprint(unique_numbers)",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "person_dict2",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "person_dict2 = { \"name\":\"Calle\", \"age\":31, \"city\":\"Stockholm\", \"job\":\"Teacher\" }\nperson_list = [] # =list()\nperson_list.append(person_dict1)\nperson_list.append(person_dict2)\nprint(person_list)\n# 8 Sets\nunique_numbers = {1, 2, 3, 4, 5, 5, 5}\nprint(unique_numbers)\nunique_fruits = set(fruits)\nprint(unique_fruits)",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "person_list",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "person_list = [] # =list()\nperson_list.append(person_dict1)\nperson_list.append(person_dict2)\nprint(person_list)\n# 8 Sets\nunique_numbers = {1, 2, 3, 4, 5, 5, 5}\nprint(unique_numbers)\nunique_fruits = set(fruits)\nprint(unique_fruits)\n# 9 Input från användare",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "unique_numbers",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "unique_numbers = {1, 2, 3, 4, 5, 5, 5}\nprint(unique_numbers)\nunique_fruits = set(fruits)\nprint(unique_fruits)\n# 9 Input från användare\n#username_input = input(\"Please enter your username: \")\n#print(f\"You entered username: {username_input}\")\n# 10 Conditionals \nage = 20\nif age >= 18:",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "unique_fruits",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "unique_fruits = set(fruits)\nprint(unique_fruits)\n# 9 Input från användare\n#username_input = input(\"Please enter your username: \")\n#print(f\"You entered username: {username_input}\")\n# 10 Conditionals \nage = 20\nif age >= 18:\n    print(\"Du får gå på klubb\")\nelif age >= 13:",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "#username_input",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "#username_input = input(\"Please enter your username: \")\n#print(f\"You entered username: {username_input}\")\n# 10 Conditionals \nage = 20\nif age >= 18:\n    print(\"Du får gå på klubb\")\nelif age >= 13:\n    print(\"Du är tonåring\")\nelse:\n    print(\"Du är ett barn\")",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "age",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "age = 20\nif age >= 18:\n    print(\"Du får gå på klubb\")\nelif age >= 13:\n    print(\"Du är tonåring\")\nelse:\n    print(\"Du är ett barn\")\n#if username_input == \"callefreme\":\n#    print(\"Hej det är ju calle!\")\n# 11 Loops",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "count",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "count = 0\nwhile count < 5:    # Vi loopar så länge (\"while\") villkoret är sant. \n    print(count)\n    count = count + 1\n# Oändlig while-loop\ncount = 1\nwhile True: # Detta villkor är alltid sant\n    print(f\"Count is now: {count}\")\n    count += 1\n    if (count >= 50):",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "count",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "count = 1\nwhile True: # Detta villkor är alltid sant\n    print(f\"Count is now: {count}\")\n    count += 1\n    if (count >= 50):\n        break   # Bryter ur loopen\nprint(\"Range loop\")\nfor i in range(5): # range(5) = [0,1,2,3,4]\n    print(i)\n# Använda listan eller strängens storlek/längd med range för att gå igenom listans index:",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "my_numbers",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "my_numbers = [5,2,1,25,61,21]\nfor i in range(len(my_numbers)):\n    print(f\"On index {i}, we have number: {my_numbers[i]}\") # Vi använder indexet 'i' för att komma åt det värde/siffra som ligger på det indexet\n# Vi kan också loopa igenom listan/strängens värden/element direkt:\nfor number in my_numbers:   # Variabeln 'number' kan egentligen heta vad som helst, men det hjälper om variabelnamnet är deskriptivt. 'number' ger en tydlig indikation på vad för typ av värde variabeln kommer vara.\n    print(f\"Number: {number}\")\n# Loopar med dictionaries\nmy_phonenumber_dict = {\"0725123112\":\"Calle\", \"0738519472\":\"Anna\", \"0703126123\":\"Bertil\"}\nfor key, item in my_phonenumber_dict.items():   # Loop-variablerna 'key' och 'item' hade kunnat heta t.ex. 'phone_number' och 'name' istället.\n    print(f\"Phone number {key} belongs to {item}\")",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "my_phonenumber_dict",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "my_phonenumber_dict = {\"0725123112\":\"Calle\", \"0738519472\":\"Anna\", \"0703126123\":\"Bertil\"}\nfor key, item in my_phonenumber_dict.items():   # Loop-variablerna 'key' och 'item' hade kunnat heta t.ex. 'phone_number' och 'name' istället.\n    print(f\"Phone number {key} belongs to {item}\")\n# Functions\ndef greet(name):\n    #print(f\"Hello, {name}\")\n    return f\"Hello, {name}!\"\ndef squared(x):\n    return x**2\ngreeting = greet(\"Calle\")",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "greeting",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "greeting = greet(\"Calle\")\nprint(greeting)\na = 3\na_squared = squared(a)\nprint(f\"{a} squared is: {a_squared}\")\n# Enumerate\nfor index, number in enumerate(my_numbers): # enumare() parar ihop varje element i listan med ett index\n    number_squared = squared(number)\n    print(f\"{number} on index {index} is: {number_squared}\")",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "a = 3\na_squared = squared(a)\nprint(f\"{a} squared is: {a_squared}\")\n# Enumerate\nfor index, number in enumerate(my_numbers): # enumare() parar ihop varje element i listan med ett index\n    number_squared = squared(number)\n    print(f\"{number} on index {index} is: {number_squared}\")",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "a_squared",
        "kind": 5,
        "importPath": "week1.intro",
        "description": "week1.intro",
        "peekOfCode": "a_squared = squared(a)\nprint(f\"{a} squared is: {a_squared}\")\n# Enumerate\nfor index, number in enumerate(my_numbers): # enumare() parar ihop varje element i listan med ett index\n    number_squared = squared(number)\n    print(f\"{number} on index {index} is: {number_squared}\")",
        "detail": "week1.intro",
        "documentation": {}
    },
    {
        "label": "arr1",
        "kind": 5,
        "importPath": "week2.data_intro",
        "description": "week2.data_intro",
        "peekOfCode": "arr1 = np.array([1, 2, 3, 4, 5])\narr2 = np.array([6, 7, 8, 9, 10])\nprint(f\"Array 1: {arr1}\")\nprint(f\"Array 2: {arr2}\")\nprint(f\"Sum of arrays: {arr1 + arr2}\")\nprint(f\"Mean of Array 1: {np.mean(arr1)}\")\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(f\"\\nMatrix:\\n{matrix}\")\nprint(f\"Transpose of matrix:\\n{matrix.T}\")\n# Pandas intro",
        "detail": "week2.data_intro",
        "documentation": {}
    },
    {
        "label": "arr2",
        "kind": 5,
        "importPath": "week2.data_intro",
        "description": "week2.data_intro",
        "peekOfCode": "arr2 = np.array([6, 7, 8, 9, 10])\nprint(f\"Array 1: {arr1}\")\nprint(f\"Array 2: {arr2}\")\nprint(f\"Sum of arrays: {arr1 + arr2}\")\nprint(f\"Mean of Array 1: {np.mean(arr1)}\")\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(f\"\\nMatrix:\\n{matrix}\")\nprint(f\"Transpose of matrix:\\n{matrix.T}\")\n# Pandas intro\n# I Pandas använder vi DataFrames, som kan beskrivas som en tabell.",
        "detail": "week2.data_intro",
        "documentation": {}
    },
    {
        "label": "matrix",
        "kind": 5,
        "importPath": "week2.data_intro",
        "description": "week2.data_intro",
        "peekOfCode": "matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(f\"\\nMatrix:\\n{matrix}\")\nprint(f\"Transpose of matrix:\\n{matrix.T}\")\n# Pandas intro\n# I Pandas använder vi DataFrames, som kan beskrivas som en tabell.\nprint(\"\\nPandas examples:\")\n# Varje key-value-pair i vår data-dictionary blir en rad i DataFramen\n# Vår data-tabell kommer ha tre kolonner: 'Name', 'Age' och 'City'\ndata = {\n    'Name': ['Alice', 'Bob', 'Charlie', 'David'],",
        "detail": "week2.data_intro",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "week2.data_intro",
        "description": "week2.data_intro",
        "peekOfCode": "data = {\n    'Name': ['Alice', 'Bob', 'Charlie', 'David'],\n    'Age': [25, 30, 35, 28],\n    'City': ['New York', 'San Francisco', 'Los Angeles', 'Chicago']\n}\ndf = pd.DataFrame(data)\nprint(\"DataFrame:\")\nprint(df)\nprint(\"\\nDescriptive statistics:\")\nprint(df.describe())",
        "detail": "week2.data_intro",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "week2.data_intro",
        "description": "week2.data_intro",
        "peekOfCode": "df = pd.DataFrame(data)\nprint(\"DataFrame:\")\nprint(df)\nprint(\"\\nDescriptive statistics:\")\nprint(df.describe())\nprint(\"\\nGrouping and aggregation:\")\ngrouped = df.groupby('City')['Age'].mean()\nprint(grouped)\n# Matplotlib intro\nprint(\"\\nMatplotlib examples:\")",
        "detail": "week2.data_intro",
        "documentation": {}
    },
    {
        "label": "grouped",
        "kind": 5,
        "importPath": "week2.data_intro",
        "description": "week2.data_intro",
        "peekOfCode": "grouped = df.groupby('City')['Age'].mean()\nprint(grouped)\n# Matplotlib intro\nprint(\"\\nMatplotlib examples:\")\nx = np.linspace(0, 10, 100)\ny1 = np.sin(x)\ny2 = np.cos(x)\nplt.figure(figsize=(10, 6))\nplt.plot(x, y1, label='sin(x)')\nplt.plot(x, y2, label='cos(x)')",
        "detail": "week2.data_intro",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "week2.data_intro",
        "description": "week2.data_intro",
        "peekOfCode": "x = np.linspace(0, 10, 100)\ny1 = np.sin(x)\ny2 = np.cos(x)\nplt.figure(figsize=(10, 6))\nplt.plot(x, y1, label='sin(x)')\nplt.plot(x, y2, label='cos(x)')\nplt.title('Sine and Cosine Functions')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.legend()",
        "detail": "week2.data_intro",
        "documentation": {}
    },
    {
        "label": "y1",
        "kind": 5,
        "importPath": "week2.data_intro",
        "description": "week2.data_intro",
        "peekOfCode": "y1 = np.sin(x)\ny2 = np.cos(x)\nplt.figure(figsize=(10, 6))\nplt.plot(x, y1, label='sin(x)')\nplt.plot(x, y2, label='cos(x)')\nplt.title('Sine and Cosine Functions')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.legend()\nplt.grid(True)",
        "detail": "week2.data_intro",
        "documentation": {}
    },
    {
        "label": "y2",
        "kind": 5,
        "importPath": "week2.data_intro",
        "description": "week2.data_intro",
        "peekOfCode": "y2 = np.cos(x)\nplt.figure(figsize=(10, 6))\nplt.plot(x, y1, label='sin(x)')\nplt.plot(x, y2, label='cos(x)')\nplt.title('Sine and Cosine Functions')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.legend()\nplt.grid(True)\nplt.show()",
        "detail": "week2.data_intro",
        "documentation": {}
    },
    {
        "label": "csv_df",
        "kind": 5,
        "importPath": "week2.data_intro",
        "description": "week2.data_intro",
        "peekOfCode": "csv_df = pd.read_csv('sample_data.csv') # Läser in CSV-filen och skapar en DataFrame 'csv_df'\nprint(csv_df)\nprint(\"\\nBasic information about the DataFrame:\")\nprint(csv_df.info())\nprint(\"\\nSummary statistics:\")\nprint(csv_df.describe())\n# Kombinera Pandas och Matplotlib\n# Plottar data från CSV-filen\nplt.figure(figsize=(10, 6))\nplt.plot(csv_df['Date'], csv_df['Sales'], marker='o')",
        "detail": "week2.data_intro",
        "documentation": {}
    },
    {
        "label": "numbers",
        "kind": 5,
        "importPath": "week2.functional",
        "description": "week2.functional",
        "peekOfCode": "numbers = [1, 2, 3, 4, 5]\n# Lambda-funktionen x: x**2 kvadrerar varje tal i listan numbers.\nsquared = list(map(lambda x: x**2, numbers))\nprint(f\"Original: {numbers}\")\nprint(f\"Squared: {squared}\")\n# Filter function\n# Filter skapar en ny lista med element som uppfyller ett visst villkor\nprint(\"\\nFilter example:\")\n# Lambda-funktionen x: x % 2 == 0 behåller endast jämna tal\neven_numbers = list(filter(lambda x: x % 2 == 0, numbers))",
        "detail": "week2.functional",
        "documentation": {}
    },
    {
        "label": "squared",
        "kind": 5,
        "importPath": "week2.functional",
        "description": "week2.functional",
        "peekOfCode": "squared = list(map(lambda x: x**2, numbers))\nprint(f\"Original: {numbers}\")\nprint(f\"Squared: {squared}\")\n# Filter function\n# Filter skapar en ny lista med element som uppfyller ett visst villkor\nprint(\"\\nFilter example:\")\n# Lambda-funktionen x: x % 2 == 0 behåller endast jämna tal\neven_numbers = list(filter(lambda x: x % 2 == 0, numbers))\nprint(f\"Original: {numbers}\")\nprint(f\"Even numbers: {even_numbers}\")",
        "detail": "week2.functional",
        "documentation": {}
    },
    {
        "label": "even_numbers",
        "kind": 5,
        "importPath": "week2.functional",
        "description": "week2.functional",
        "peekOfCode": "even_numbers = list(filter(lambda x: x % 2 == 0, numbers))\nprint(f\"Original: {numbers}\")\nprint(f\"Even numbers: {even_numbers}\")\n# Reduce function\n# Reduce applicerar en funktion av två argument kumulativt på varje element i en lista\nprint(\"\\nReduce example:\")\n# Denna lambda-funktion har två argument (x, y) som returnerar x + y, dvs. summerar alla tal i listan.\nsum_of_numbers = reduce(lambda x, y: x + y, numbers)\nprint(f\"Original: {numbers}\")\nprint(f\"Sum: {sum_of_numbers}\")",
        "detail": "week2.functional",
        "documentation": {}
    },
    {
        "label": "sum_of_numbers",
        "kind": 5,
        "importPath": "week2.functional",
        "description": "week2.functional",
        "peekOfCode": "sum_of_numbers = reduce(lambda x, y: x + y, numbers)\nprint(f\"Original: {numbers}\")\nprint(f\"Sum: {sum_of_numbers}\")\n#reduce kan användas för mycket mer än bara addition. Du kan använda den för att:\n# Hitta det största värdet i en lista\n# Multiplicera alla tal i en lista\n# Bygga en sträng från en lista av ord\n# List comprehension\n# List comprehension är ett koncist sätt att skapa listor baserat på existerande listor\nprint(\"\\nList comprehension examples:\")",
        "detail": "week2.functional",
        "documentation": {}
    },
    {
        "label": "squares",
        "kind": 5,
        "importPath": "week2.functional",
        "description": "week2.functional",
        "peekOfCode": "squares = [x**2 for x in range(1, 6)]\nprint(f\"Squares: {squares}\")\n# Här skapas en lista med kvadrater av jämna tal mellan 1 och 10\neven_squares = [x**2 for x in range(1, 11) if x % 2 == 0]\nprint(f\"Even squares: {even_squares}\")\n# Lambda functions\n# Lambda-funktioner är små anonyma funktioner som kan ha vilket antal argument som helst,\n# men kan bara ha ett uttryck\nprint(\"\\nLambda function examples:\")\nmultiply = lambda x, y: x * y",
        "detail": "week2.functional",
        "documentation": {}
    },
    {
        "label": "even_squares",
        "kind": 5,
        "importPath": "week2.functional",
        "description": "week2.functional",
        "peekOfCode": "even_squares = [x**2 for x in range(1, 11) if x % 2 == 0]\nprint(f\"Even squares: {even_squares}\")\n# Lambda functions\n# Lambda-funktioner är små anonyma funktioner som kan ha vilket antal argument som helst,\n# men kan bara ha ett uttryck\nprint(\"\\nLambda function examples:\")\nmultiply = lambda x, y: x * y\nprint(f\"4 * 5 = {multiply(4, 5)}\")\n# Sorting with lambda\n# Lambda-funktioner kan användas som nycklar vid sortering",
        "detail": "week2.functional",
        "documentation": {}
    },
    {
        "label": "multiply",
        "kind": 5,
        "importPath": "week2.functional",
        "description": "week2.functional",
        "peekOfCode": "multiply = lambda x, y: x * y\nprint(f\"4 * 5 = {multiply(4, 5)}\")\n# Sorting with lambda\n# Lambda-funktioner kan användas som nycklar vid sortering\nprint(\"\\nSorting with lambda:\")\npairs = [(1, 'one'), (3, 'three'), (2, 'two')]\n# Här sorteras paren baserat på det andra elementet i varje par (strängen)\nsorted_pairs = sorted(pairs, key=lambda pair: pair[1])\nprint(f\"Sorted by second element: {sorted_pairs}\")\n# Combining functional concepts",
        "detail": "week2.functional",
        "documentation": {}
    },
    {
        "label": "pairs",
        "kind": 5,
        "importPath": "week2.functional",
        "description": "week2.functional",
        "peekOfCode": "pairs = [(1, 'one'), (3, 'three'), (2, 'two')]\n# Här sorteras paren baserat på det andra elementet i varje par (strängen)\nsorted_pairs = sorted(pairs, key=lambda pair: pair[1])\nprint(f\"Sorted by second element: {sorted_pairs}\")\n# Combining functional concepts\nprint(\"\\nCombining concepts:\")\nsentence = \"The quick brown fox jumps over the lazy dog\"\n# Denna nästa rad gör följande:\n# 1. Delar upp meningen i ord\n# 2. Filtrerar ut ord som inte börjar med en versal",
        "detail": "week2.functional",
        "documentation": {}
    },
    {
        "label": "sorted_pairs",
        "kind": 5,
        "importPath": "week2.functional",
        "description": "week2.functional",
        "peekOfCode": "sorted_pairs = sorted(pairs, key=lambda pair: pair[1])\nprint(f\"Sorted by second element: {sorted_pairs}\")\n# Combining functional concepts\nprint(\"\\nCombining concepts:\")\nsentence = \"The quick brown fox jumps over the lazy dog\"\n# Denna nästa rad gör följande:\n# 1. Delar upp meningen i ord\n# 2. Filtrerar ut ord som inte börjar med en versal\n# 3. Mappar len-funktionen över de kvarvarande orden för att få deras längder\nword_lengths = list(map(len, filter(lambda word: not word.islower(), sentence.split())))",
        "detail": "week2.functional",
        "documentation": {}
    },
    {
        "label": "sentence",
        "kind": 5,
        "importPath": "week2.functional",
        "description": "week2.functional",
        "peekOfCode": "sentence = \"The quick brown fox jumps over the lazy dog\"\n# Denna nästa rad gör följande:\n# 1. Delar upp meningen i ord\n# 2. Filtrerar ut ord som inte börjar med en versal\n# 3. Mappar len-funktionen över de kvarvarande orden för att få deras längder\nword_lengths = list(map(len, filter(lambda word: not word.islower(), sentence.split())))\nprint(f\"Lengths of words starting with uppercase: {word_lengths}\")",
        "detail": "week2.functional",
        "documentation": {}
    },
    {
        "label": "word_lengths",
        "kind": 5,
        "importPath": "week2.functional",
        "description": "week2.functional",
        "peekOfCode": "word_lengths = list(map(len, filter(lambda word: not word.islower(), sentence.split())))\nprint(f\"Lengths of words starting with uppercase: {word_lengths}\")",
        "detail": "week2.functional",
        "documentation": {}
    },
    {
        "label": "Book",
        "kind": 6,
        "importPath": "week2.libraryapp",
        "description": "week2.libraryapp",
        "peekOfCode": "class Book:\n    # Klassvariabel för att räkna antalet böcker\n    book_count = 0  # Adderas med 1 för varje bok-objekt som skapas\n    def __init__(self, title, author, year, genre, borrowed, pages):\n        # Set up attributes\n        self.title = title\n        self.author = author\n        self.year = year\n        self.genre = genre\n        self.is_borrowed = borrowed",
        "detail": "week2.libraryapp",
        "documentation": {}
    },
    {
        "label": "Library",
        "kind": 6,
        "importPath": "week2.libraryapp",
        "description": "week2.libraryapp",
        "peekOfCode": "class Library:\n    def __init__(self, name, books=[]):\n        self.books = books\n        self.users = {}\n        self.name = \"Kungliga Biblioteket\"\n    @log_method_call\n    def add_book(self, book):\n        self.books.append(book)\n    @log_method_call\n    def remove_book(self, book):",
        "detail": "week2.libraryapp",
        "documentation": {}
    },
    {
        "label": "log_method_call",
        "kind": 2,
        "importPath": "week2.libraryapp",
        "description": "week2.libraryapp",
        "peekOfCode": "def log_method_call(func):\n    def wrapper(*args, **kwargs):\n        print(f\"Anropar metod: {func.__name__}\")\n        return func(*args, **kwargs)\n    return wrapper\nclass Book:\n    # Klassvariabel för att räkna antalet böcker\n    book_count = 0  # Adderas med 1 för varje bok-objekt som skapas\n    def __init__(self, title, author, year, genre, borrowed, pages):\n        # Set up attributes",
        "detail": "week2.libraryapp",
        "documentation": {}
    },
    {
        "label": "run_interactive_program",
        "kind": 2,
        "importPath": "week2.libraryapp",
        "description": "week2.libraryapp",
        "peekOfCode": "def run_interactive_program(library):\n    while True:\n        print(\"\\n--- Bibliotekssystem ---\")\n        print(\"1. Visa alla böcker\")\n        print(\"2. Låna en bok\")\n        print(\"3. Återlämna en bok\")\n        print(\"4. Visa lånade böcker\")\n        print(\"5. Avsluta\")\n        choice = input(\"Välj en åtgärd (1-5): \")\n        if choice == '1':",
        "detail": "week2.libraryapp",
        "documentation": {}
    },
    {
        "label": "run_noninteractive_program",
        "kind": 2,
        "importPath": "week2.libraryapp",
        "description": "week2.libraryapp",
        "peekOfCode": "def run_noninteractive_program(library):\n        # Skapa en bibliotekarie och en låntagare om de inte redan finns\n    if 'LIB001' not in library.users:\n        librarian = Librarian(\"Anna Bibliotekarie\", \"LIB001\", \"Skönlitteratur\")\n        library.users['LIB001'] = librarian\n    else:\n        librarian = library.users['LIB001']\n    if 'LOAN001' not in library.users:\n        loaner = Loaner(\"Erik Låntagare\", \"LOAN001\")\n        library.users['LOAN001'] = loaner",
        "detail": "week2.libraryapp",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "week2.libraryapp",
        "description": "week2.libraryapp",
        "peekOfCode": "def main():\n    try:\n        library = Library.load_from_file('library_data.json')\n        print(f\"Bibliotek laddat: {library.name}\")\n    except FileNotFoundError:\n        library = Library(\"Kungliga Biblioteket\")\n        print(f\"Nytt bibliotek skapat: {library.name}\")\n    library.load_users_from_file('library_users.txt')\n    interactive_program = input(\"Vill du köra en interaktiv version av programmet (ja/nej)? \")\n    if interactive_program.lower() == \"ja\":",
        "detail": "week2.libraryapp",
        "documentation": {}
    },
    {
        "label": "Book",
        "kind": 6,
        "importPath": "week2.libraryAppClasses",
        "description": "week2.libraryAppClasses",
        "peekOfCode": "class Book:\n    def __init__(self, title, author, year, genre, borrowed, pages):\n        self.title = title\n        self.author = author\n        self.year = year\n        self.genre = genre\n        self.is_borrowed = borrowed\n        self.pages = pages\n    def __str__(self):\n        return f\"{self.title} by {self.author} ({self.year})\"",
        "detail": "week2.libraryAppClasses",
        "documentation": {}
    },
    {
        "label": "Library",
        "kind": 6,
        "importPath": "week2.libraryAppClasses",
        "description": "week2.libraryAppClasses",
        "peekOfCode": "class Library:\n    def __init__(self, books=None):\n        if books is None:\n            books = []\n        self.books = []\n    def add_book(self, book):\n        self.books.append(book)\n    def remove_book(self, book):\n        self.books.remove(book)\n    def find_book(self, book):",
        "detail": "week2.libraryAppClasses",
        "documentation": {}
    },
    {
        "label": "bookObj",
        "kind": 5,
        "importPath": "week2.libraryAppClasses",
        "description": "week2.libraryAppClasses",
        "peekOfCode": "bookObj = Book(\"kucuk prens\", \"senol\", 1999, \"klasik\", False, 232)\nprint(bookObj)\nprint(bookObj.borrow())\nprint(bookObj.is_borrowed)\nbookObj.return_book()\nprint(bookObj.is_borrowed)\nlibrary = Library()\nlibrary.add_book(bookObj)\nlibrary.add_book(Book(\"1984\", \"George Orwell\", 1945, \"fact\", False, 312))\nlibrary.add_book(Book(\"Kill a mockingbird\", \"harper lee\", 1925, \"fictions\", False, 432))",
        "detail": "week2.libraryAppClasses",
        "documentation": {}
    },
    {
        "label": "library",
        "kind": 5,
        "importPath": "week2.libraryAppClasses",
        "description": "week2.libraryAppClasses",
        "peekOfCode": "library = Library()\nlibrary.add_book(bookObj)\nlibrary.add_book(Book(\"1984\", \"George Orwell\", 1945, \"fact\", False, 312))\nlibrary.add_book(Book(\"Kill a mockingbird\", \"harper lee\", 1925, \"fictions\", False, 432))\nprint(library.books)\nprint(\"--- list --------\")\nprint(library.list_books())\nprint(\"--- list --------\")\nlist(map(print, library.list_books()))\nif book_to_borrow := library.find_book(\"1984\"):",
        "detail": "week2.libraryAppClasses",
        "documentation": {}
    },
    {
        "label": "greet",
        "kind": 2,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "def greet(name):\n    #print(f\"Hello, {name}\")\n    return f\"Hello, {name}!\"\ndef squared(x):\n    return x**2\ngreeting = greet(\"Calle\")\nprint(greeting)\na = 3\na_squared = squared(a)\nprint(f\"{a} squared is: {a_squared}\")",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "squared",
        "kind": 2,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "def squared(x):\n    return x**2\ngreeting = greet(\"Calle\")\nprint(greeting)\na = 3\na_squared = squared(a)\nprint(f\"{a} squared is: {a_squared}\")\n# Enumerate\nfor index, number in enumerate(my_numbers): # enumare() parar ihop varje element i listan med ett index\n    number_squared = squared(number)",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "random_int",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "random_int = random.randint(0,5)\nprint(random_int)\n'''\nmulti-\nline\ncomment\n'''\n# 1. Basic syntrax, kommentarer, printing\nprint(\"Hej, klassen!\") # Printa i Python\n# 2. Variabler och datatyper",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "x = 30               # int\ny = 3.14            # float\nname = \"Calle\"     # string\nis_fun = True       # boolean\n# 3. Type checking, typkonverterting\nprint(type(x))\nz = str(x)\nprint(type(z))\na = \"10\"\nb = int(a) + 1",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "y = 3.14            # float\nname = \"Calle\"     # string\nis_fun = True       # boolean\n# 3. Type checking, typkonverterting\nprint(type(x))\nz = str(x)\nprint(type(z))\na = \"10\"\nb = int(a) + 1\nb += 1      # Samma som b = b + 1",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "name",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "name = \"Calle\"     # string\nis_fun = True       # boolean\n# 3. Type checking, typkonverterting\nprint(type(x))\nz = str(x)\nprint(type(z))\na = \"10\"\nb = int(a) + 1\nb += 1      # Samma som b = b + 1\nprint(b)",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "is_fun",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "is_fun = True       # boolean\n# 3. Type checking, typkonverterting\nprint(type(x))\nz = str(x)\nprint(type(z))\na = \"10\"\nb = int(a) + 1\nb += 1      # Samma som b = b + 1\nprint(b)\n# 4 string operations",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "z",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "z = str(x)\nprint(type(z))\na = \"10\"\nb = int(a) + 1\nb += 1      # Samma som b = b + 1\nprint(b)\n# 4 string operations\nprint(len(name))\nprint(name.upper())\nprint(name.lower())",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "a = \"10\"\nb = int(a) + 1\nb += 1      # Samma som b = b + 1\nprint(b)\n# 4 string operations\nprint(len(name))\nprint(name.upper())\nprint(name.lower())\nstripped_str = \"  string with spaces  \".strip()\nfully_stripped_str = \"  string with spaces  \".replace(\" \", \"\")",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "b = int(a) + 1\nb += 1      # Samma som b = b + 1\nprint(b)\n# 4 string operations\nprint(len(name))\nprint(name.upper())\nprint(name.lower())\nstripped_str = \"  string with spaces  \".strip()\nfully_stripped_str = \"  string with spaces  \".replace(\" \", \"\")\nmy_sentence_string = \"a string with multiple words\"",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "stripped_str",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "stripped_str = \"  string with spaces  \".strip()\nfully_stripped_str = \"  string with spaces  \".replace(\" \", \"\")\nmy_sentence_string = \"a string with multiple words\"\nstring_list = my_sentence_string.split(\" \")\nprint(string_list)\n# 5 string formatting\nprint(f\"My name is {name} and I'm {x} years old\")\nprint(\"Pi is approximately {:.2f}\".format(y))\n# 6 Lists\nfruits = [\"apple\", \"banana\", \"cherry\", \"apple\"]",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "fully_stripped_str",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "fully_stripped_str = \"  string with spaces  \".replace(\" \", \"\")\nmy_sentence_string = \"a string with multiple words\"\nstring_list = my_sentence_string.split(\" \")\nprint(string_list)\n# 5 string formatting\nprint(f\"My name is {name} and I'm {x} years old\")\nprint(\"Pi is approximately {:.2f}\".format(y))\n# 6 Lists\nfruits = [\"apple\", \"banana\", \"cherry\", \"apple\"]\nfruits.append(\"date\")",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "my_sentence_string",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "my_sentence_string = \"a string with multiple words\"\nstring_list = my_sentence_string.split(\" \")\nprint(string_list)\n# 5 string formatting\nprint(f\"My name is {name} and I'm {x} years old\")\nprint(\"Pi is approximately {:.2f}\".format(y))\n# 6 Lists\nfruits = [\"apple\", \"banana\", \"cherry\", \"apple\"]\nfruits.append(\"date\")\nfruits.insert(1, \"strawberry\")",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "string_list",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "string_list = my_sentence_string.split(\" \")\nprint(string_list)\n# 5 string formatting\nprint(f\"My name is {name} and I'm {x} years old\")\nprint(\"Pi is approximately {:.2f}\".format(y))\n# 6 Lists\nfruits = [\"apple\", \"banana\", \"cherry\", \"apple\"]\nfruits.append(\"date\")\nfruits.insert(1, \"strawberry\")\nprint(fruits[2])",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "fruits",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "fruits = [\"apple\", \"banana\", \"cherry\", \"apple\"]\nfruits.append(\"date\")\nfruits.insert(1, \"strawberry\")\nprint(fruits[2])\nprint(fruits)\nfruits_string = \", \".join(fruits)\n# 7 Dictionaries\nperson_dict1 = { \"name\":\"Alice\", \"age\":30, \"city\":\"New York\" }\nprint(person_dict1[\"name\"])\nperson_dict1[\"job\"] = \"Developer\"",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "fruits_string",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "fruits_string = \", \".join(fruits)\n# 7 Dictionaries\nperson_dict1 = { \"name\":\"Alice\", \"age\":30, \"city\":\"New York\" }\nprint(person_dict1[\"name\"])\nperson_dict1[\"job\"] = \"Developer\"\nprint(person_dict1[\"job\"])\nperson_dict2 = { \"name\":\"Calle\", \"age\":31, \"city\":\"Stockholm\", \"job\":\"Teacher\" }\nperson_list = [] # =list()\nperson_list.append(person_dict1)\nperson_list.append(person_dict2)",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "person_dict1",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "person_dict1 = { \"name\":\"Alice\", \"age\":30, \"city\":\"New York\" }\nprint(person_dict1[\"name\"])\nperson_dict1[\"job\"] = \"Developer\"\nprint(person_dict1[\"job\"])\nperson_dict2 = { \"name\":\"Calle\", \"age\":31, \"city\":\"Stockholm\", \"job\":\"Teacher\" }\nperson_list = [] # =list()\nperson_list.append(person_dict1)\nperson_list.append(person_dict2)\nprint(person_list)\n# 8 Sets & Tuples",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "person_dict1[\"job\"]",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "person_dict1[\"job\"] = \"Developer\"\nprint(person_dict1[\"job\"])\nperson_dict2 = { \"name\":\"Calle\", \"age\":31, \"city\":\"Stockholm\", \"job\":\"Teacher\" }\nperson_list = [] # =list()\nperson_list.append(person_dict1)\nperson_list.append(person_dict2)\nprint(person_list)\n# 8 Sets & Tuples\nunique_numbers = {1, 2, 3, 4, 5, 5, 5}\nprint(unique_numbers)",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "person_dict2",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "person_dict2 = { \"name\":\"Calle\", \"age\":31, \"city\":\"Stockholm\", \"job\":\"Teacher\" }\nperson_list = [] # =list()\nperson_list.append(person_dict1)\nperson_list.append(person_dict2)\nprint(person_list)\n# 8 Sets & Tuples\nunique_numbers = {1, 2, 3, 4, 5, 5, 5}\nprint(unique_numbers)\nunique_fruits = set(fruits)\nprint(unique_fruits)",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "person_list",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "person_list = [] # =list()\nperson_list.append(person_dict1)\nperson_list.append(person_dict2)\nprint(person_list)\n# 8 Sets & Tuples\nunique_numbers = {1, 2, 3, 4, 5, 5, 5}\nprint(unique_numbers)\nunique_fruits = set(fruits)\nprint(unique_fruits)\nnumbers_tuple = tuple(unique_numbers) # Tuplar är listor som ej går att modifiera, dvs innehållet går inte att ändra på.",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "unique_numbers",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "unique_numbers = {1, 2, 3, 4, 5, 5, 5}\nprint(unique_numbers)\nunique_fruits = set(fruits)\nprint(unique_fruits)\nnumbers_tuple = tuple(unique_numbers) # Tuplar är listor som ej går att modifiera, dvs innehållet går inte att ändra på.\n# 9 Input från användare\n#username_input = input(\"Please enter your username: \")\n#print(f\"You entered username: {username_input}\")\n# 10 Conditionals \nage = 20",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "unique_fruits",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "unique_fruits = set(fruits)\nprint(unique_fruits)\nnumbers_tuple = tuple(unique_numbers) # Tuplar är listor som ej går att modifiera, dvs innehållet går inte att ändra på.\n# 9 Input från användare\n#username_input = input(\"Please enter your username: \")\n#print(f\"You entered username: {username_input}\")\n# 10 Conditionals \nage = 20\nif age >= 18:\n    print(\"Du får gå på klubb\")",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "numbers_tuple",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "numbers_tuple = tuple(unique_numbers) # Tuplar är listor som ej går att modifiera, dvs innehållet går inte att ändra på.\n# 9 Input från användare\n#username_input = input(\"Please enter your username: \")\n#print(f\"You entered username: {username_input}\")\n# 10 Conditionals \nage = 20\nif age >= 18:\n    print(\"Du får gå på klubb\")\nelif age >= 13:\n    print(\"Du är tonåring\")",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "#username_input",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "#username_input = input(\"Please enter your username: \")\n#print(f\"You entered username: {username_input}\")\n# 10 Conditionals \nage = 20\nif age >= 18:\n    print(\"Du får gå på klubb\")\nelif age >= 13:\n    print(\"Du är tonåring\")\nelse:\n    print(\"Du är ett barn\")",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "age",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "age = 20\nif age >= 18:\n    print(\"Du får gå på klubb\")\nelif age >= 13:\n    print(\"Du är tonåring\")\nelse:\n    print(\"Du är ett barn\")\n# match kräver Python 3.10 eller senare\n'''\nnum = 3",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "num",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "num = 3\nmatch num:\n    case 1:\n        print(\"One\")\n    case 2:\n        print(\"Two\")\n    case 3:\n        print(\"Three\")\n    case 4:\n        print(\"Four\")",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "count",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "count = 0\nwhile count < 5:    # Vi loopar så länge (\"while\") villkoret är sant. \n    print(count)\n    count = count + 1\n# Oändlig while-loop\ncount = 1\nwhile True: # Detta villkor är alltid sant\n    print(f\"Count is now: {count}\")\n    count += 1\n    if (count >= 50):",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "count",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "count = 1\nwhile True: # Detta villkor är alltid sant\n    print(f\"Count is now: {count}\")\n    count += 1\n    if (count >= 50):\n        break   # Bryter ur loopen\nprint(\"Range loop\")\nfor i in range(5): # range(5) = [0,1,2,3,4]\n    print(i)\n# Använda listan eller strängens storlek/längd med range för att gå igenom listans index:",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "my_numbers",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "my_numbers = [5,2,1,25,61,21]\nfor i in range(len(my_numbers)):\n    print(f\"On index {i}, we have number: {my_numbers[i]}\") # Vi använder indexet 'i' för att komma åt det värde/siffra som ligger på det indexet\n# Vi kan också loopa igenom listan/strängens värden/element direkt:\nfor number in my_numbers:   # Variabeln 'number' kan egentligen heta vad som helst, men det hjälper om variabelnamnet är deskriptivt. 'number' ger en tydlig indikation på vad för typ av värde variabeln kommer vara.\n    print(f\"Number: {number}\")\n# Loopar med dictionaries\nmy_phonenumber_dict = {\"0725123112\":\"Calle\", \"0738519472\":\"Anna\", \"0703126123\":\"Bertil\"}\nfor key, item in my_phonenumber_dict.items():   # Loop-variablerna 'key' och 'item' hade kunnat heta t.ex. 'phone_number' och 'name' istället.\n    print(f\"Phone number {key} belongs to {item}\")",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "my_phonenumber_dict",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "my_phonenumber_dict = {\"0725123112\":\"Calle\", \"0738519472\":\"Anna\", \"0703126123\":\"Bertil\"}\nfor key, item in my_phonenumber_dict.items():   # Loop-variablerna 'key' och 'item' hade kunnat heta t.ex. 'phone_number' och 'name' istället.\n    print(f\"Phone number {key} belongs to {item}\")\n# Functions\ndef greet(name):\n    #print(f\"Hello, {name}\")\n    return f\"Hello, {name}!\"\ndef squared(x):\n    return x**2\ngreeting = greet(\"Calle\")",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "greeting",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "greeting = greet(\"Calle\")\nprint(greeting)\na = 3\na_squared = squared(a)\nprint(f\"{a} squared is: {a_squared}\")\n# Enumerate\nfor index, number in enumerate(my_numbers): # enumare() parar ihop varje element i listan med ett index\n    number_squared = squared(number)\n    print(f\"{number} on index {index} is: {number_squared}\")",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "a = 3\na_squared = squared(a)\nprint(f\"{a} squared is: {a_squared}\")\n# Enumerate\nfor index, number in enumerate(my_numbers): # enumare() parar ihop varje element i listan med ett index\n    number_squared = squared(number)\n    print(f\"{number} on index {index} is: {number_squared}\")",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "a_squared",
        "kind": 5,
        "importPath": "week2.python-rep",
        "description": "week2.python-rep",
        "peekOfCode": "a_squared = squared(a)\nprint(f\"{a} squared is: {a_squared}\")\n# Enumerate\nfor index, number in enumerate(my_numbers): # enumare() parar ihop varje element i listan med ett index\n    number_squared = squared(number)\n    print(f\"{number} on index {index} is: {number_squared}\")",
        "detail": "week2.python-rep",
        "documentation": {}
    },
    {
        "label": "Person",
        "kind": 6,
        "importPath": "week2.uppy",
        "description": "week2.uppy",
        "peekOfCode": "class Person:\n    def __init__(self,name,age):\n            self.name=name\n            self.age=age\n            self.hobbies=[]\n    def introduce(self):\n        return f\"Hi, my name is {self.name} and i am {self.age} years old.\"\n# Exempeluppgift del 2 - Attribut och metoder för Person\n# Utöka Person-klassen från föregående uppgift:\n# Lägg till ett attribut hobbies som en lista i konstruktorn.",
        "detail": "week2.uppy",
        "documentation": {}
    },
    {
        "label": "User",
        "kind": 6,
        "importPath": "week2.users",
        "description": "week2.users",
        "peekOfCode": "class User:\n    def __init__(self, name, user_id):\n        self.name = name\n        self.user_id = user_id  # Unikt för varje användare\n    def __str__(self):\n        return f\"{self.name} (ID: {self.user_id})\"\n# Arv: Loaner (låntagare) ärver från User. Loaner är en \"child\" till User, som är en \"parent\" class. \nclass Loaner(User):\n    def __init__(self, name, user_id):\n        super().__init__(name, user_id)",
        "detail": "week2.users",
        "documentation": {}
    },
    {
        "label": "Loaner",
        "kind": 6,
        "importPath": "week2.users",
        "description": "week2.users",
        "peekOfCode": "class Loaner(User):\n    def __init__(self, name, user_id):\n        super().__init__(name, user_id)\n        self.borrowed_books = []\n    def borrow_book(self, book):\n        if book.borrow():\n            self.borrowed_books.append(book)\n            book.borrower_id = self.user_id\n            return True\n        return False",
        "detail": "week2.users",
        "documentation": {}
    },
    {
        "label": "Librarian",
        "kind": 6,
        "importPath": "week2.users",
        "description": "week2.users",
        "peekOfCode": "class Librarian(User):\n    def __init__(self, name, user_id, department):\n        super().__init__(name, user_id)\n        self.department = department\n        self.working_hours = {\"Monday\": [9,17], \"Tuesday\": [9,17], \"Wednesday\": [9,17], \"Thursday\": [9,17], \"Friday\": [9,16], \"Saturday\": [10,16], \"Sunday\": [11,16]}\n    def add_book_to_library(self, library, book):\n        library.add_book(book)\n    def remove_book_from_library(self, library, book):\n        library.remove_book(book)",
        "detail": "week2.users",
        "documentation": {}
    },
    {
        "label": "StockAnalyzer",
        "kind": 6,
        "importPath": "week3.stock analyzer.stockapp",
        "description": "week3.stock analyzer.stockapp",
        "peekOfCode": "class StockAnalyzer:\n    def __init__(self, csv_file):\n        self.df = self.load_data(csv_file)\n        self.clean_data()\n        self.calculate_additional_features()\n    def load_data(self, csv_file):\n        df = pd.read_csv(csv_file, index_col='Date', parse_dates=True)\n        df.sort_index(inplace=True)\n        return df\n    def clean_data(self):",
        "detail": "week3.stock analyzer.stockapp",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "week3.stock analyzer.stockapp",
        "description": "week3.stock analyzer.stockapp",
        "peekOfCode": "def main():\n    analyzer = StockAnalyzer('stock_data_large.csv')  # Use stock_data.csv or stock_data_large.csv\n    print(\"Generating visualizations...\")\n    analyzer.plot_stock_prices()\n    analyzer.plot_candlestick_chart()\n    analyzer.plot_returns_histogram()\n    print(\"Running simple moving average strategy...\")\n    analyzer.simple_moving_average_strategy()\n    analyzer.plot_strategy_performance()\n    print(\"Generating price predictions...\")",
        "detail": "week3.stock analyzer.stockapp",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "week3.weather analyzer.weatherapp",
        "description": "week3.weather analyzer.weatherapp",
        "peekOfCode": "data = pd.read_csv('weather_data.csv', parse_dates=['Date'])\n# Hantera saknade värden genom att fylla med genomsnitt eller ta bort rader\ndata.fillna(method='ffill', inplace=True)\n# Skapa en ny kolumn för månad från datumet\ndata['Month'] = data['Date'].dt.to_period('M')\n# Beräkna genomsnittlig temperatur per månad\nmonthly_avg_temp = data.groupby('Month')['Temperature'].mean()\nprint(monthly_avg_temp)",
        "detail": "week3.weather analyzer.weatherapp",
        "documentation": {}
    },
    {
        "label": "data['Month']",
        "kind": 5,
        "importPath": "week3.weather analyzer.weatherapp",
        "description": "week3.weather analyzer.weatherapp",
        "peekOfCode": "data['Month'] = data['Date'].dt.to_period('M')\n# Beräkna genomsnittlig temperatur per månad\nmonthly_avg_temp = data.groupby('Month')['Temperature'].mean()\nprint(monthly_avg_temp)",
        "detail": "week3.weather analyzer.weatherapp",
        "documentation": {}
    },
    {
        "label": "monthly_avg_temp",
        "kind": 5,
        "importPath": "week3.weather analyzer.weatherapp",
        "description": "week3.weather analyzer.weatherapp",
        "peekOfCode": "monthly_avg_temp = data.groupby('Month')['Temperature'].mean()\nprint(monthly_avg_temp)",
        "detail": "week3.weather analyzer.weatherapp",
        "documentation": {}
    },
    {
        "label": "n_samples",
        "kind": 5,
        "importPath": "week3.generate_sample_data",
        "description": "week3.generate_sample_data",
        "peekOfCode": "n_samples = 1000\ndata = {\n    'Name': [f'Person_{i}' for i in range(n_samples)],\n    'Age': np.random.randint(18, 80, n_samples),\n    'City': np.random.choice(['New York', 'Los Angeles', 'Chicago', 'Houston', 'Phoenix'], n_samples),\n    'Salary': np.random.normal(50000, 15000, n_samples).astype(int),\n    'Years_Experience': np.random.randint(0, 30, n_samples),\n    'Department': np.random.choice(['Sales', 'Marketing', 'Engineering', 'HR', 'Finance'], n_samples),\n    'Performance_Score': np.random.uniform(1, 5, n_samples).round(2),\n    'Training_Hours': np.random.poisson(40, n_samples),",
        "detail": "week3.generate_sample_data",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "week3.generate_sample_data",
        "description": "week3.generate_sample_data",
        "peekOfCode": "data = {\n    'Name': [f'Person_{i}' for i in range(n_samples)],\n    'Age': np.random.randint(18, 80, n_samples),\n    'City': np.random.choice(['New York', 'Los Angeles', 'Chicago', 'Houston', 'Phoenix'], n_samples),\n    'Salary': np.random.normal(50000, 15000, n_samples).astype(int),\n    'Years_Experience': np.random.randint(0, 30, n_samples),\n    'Department': np.random.choice(['Sales', 'Marketing', 'Engineering', 'HR', 'Finance'], n_samples),\n    'Performance_Score': np.random.uniform(1, 5, n_samples).round(2),\n    'Training_Hours': np.random.poisson(40, n_samples),\n    'Satisfaction_Level': np.random.choice(['Low', 'Medium', 'High'], n_samples),",
        "detail": "week3.generate_sample_data",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "week3.generate_sample_data",
        "description": "week3.generate_sample_data",
        "peekOfCode": "df = pd.DataFrame(data)\n# Add some NaN values\ndf.loc[np.random.choice(df.index, 50), 'Salary'] = np.nan\ndf.loc[np.random.choice(df.index, 50), 'Performance_Score'] = np.nan\n# Save to CSV\ndf.to_csv('sample_data0.csv', index=False)\nprint(\"sample_data0.csv has been generated successfully.\")",
        "detail": "week3.generate_sample_data",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "week3.more_data",
        "description": "week3.more_data",
        "peekOfCode": "df = pd.DataFrame(\n    {\n        \"Name\": [\"Alice\", \"Bob\", \"Charlie\"],\n        \"Age\": [25, 30, 35],\n        \"City\": [\"New York\", \"Los Angeles\", \"Chicago\"],\n    }\n)\nprint(\"Basic DataFrame:\")\nprint(df)\n# Reading CSV file",
        "detail": "week3.more_data",
        "documentation": {}
    },
    {
        "label": "csv_df",
        "kind": 5,
        "importPath": "week3.more_data",
        "description": "week3.more_data",
        "peekOfCode": "csv_df = pd.read_csv(\"sample_data0.csv\")\nprint(\"\\nFirst 5 rows of CSV data:\")\nprint(csv_df.head())\n# Basic information about the DataFrame\nprint(\"\\nDataFrame Info:\")\nprint(csv_df.info())\n# Statistical summary\nprint(\"\\nStatistical Summary:\")\nprint(csv_df.describe())\n# Grouping and aggregation",
        "detail": "week3.more_data",
        "documentation": {}
    },
    {
        "label": "filled_df",
        "kind": 5,
        "importPath": "week3.more_data",
        "description": "week3.more_data",
        "peekOfCode": "filled_df = csv_df.fillna(0)\nprint(filled_df.head())\nprint(\"\\nDropping rows with NaN values:\")\ncleaned_df = csv_df.dropna()\nprint(cleaned_df.head())\n# Data manipulation\nprint(\"\\nAdding a new column:\")\ncsv_df[\"Experience_Category\"] = pd.cut(\n    csv_df[\"Years_Experience\"],\n    bins=[0, 5, 10, 20, 30],",
        "detail": "week3.more_data",
        "documentation": {}
    },
    {
        "label": "cleaned_df",
        "kind": 5,
        "importPath": "week3.more_data",
        "description": "week3.more_data",
        "peekOfCode": "cleaned_df = csv_df.dropna()\nprint(cleaned_df.head())\n# Data manipulation\nprint(\"\\nAdding a new column:\")\ncsv_df[\"Experience_Category\"] = pd.cut(\n    csv_df[\"Years_Experience\"],\n    bins=[0, 5, 10, 20, 30],\n    labels=[\"Entry\", \"Mid\", \"Senior\", \"Expert\"],\n)\nprint(csv_df[[\"Name\", \"Years_Experience\", \"Experience_Category\"]].head(10))",
        "detail": "week3.more_data",
        "documentation": {}
    },
    {
        "label": "csv_df[\"Experience_Category\"]",
        "kind": 5,
        "importPath": "week3.more_data",
        "description": "week3.more_data",
        "peekOfCode": "csv_df[\"Experience_Category\"] = pd.cut(\n    csv_df[\"Years_Experience\"],\n    bins=[0, 5, 10, 20, 30],\n    labels=[\"Entry\", \"Mid\", \"Senior\", \"Expert\"],\n)\nprint(csv_df[[\"Name\", \"Years_Experience\", \"Experience_Category\"]].head(10))\n# NumPy Examples\nprint(\"\\nNumPy Examples:\")\n# Creating arrays\narr1 = np.array([1, 2, 3, 4, 5])",
        "detail": "week3.more_data",
        "documentation": {}
    },
    {
        "label": "arr1",
        "kind": 5,
        "importPath": "week3.more_data",
        "description": "week3.more_data",
        "peekOfCode": "arr1 = np.array([1, 2, 3, 4, 5])\narr2 = np.array([6, 7, 8, 9, 10])\nprint(\"Array 1:\", arr1)\nprint(\"Array 2:\", arr2)\n# Array operations\nprint(\"Sum of arrays:\", arr1 + arr2)\nprint(\"Product of arrays:\", arr1 * arr2)\nprint(\"Mean of Array 1:\", np.mean(arr1))\n# Creating matrices\nmatrix1 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])",
        "detail": "week3.more_data",
        "documentation": {}
    },
    {
        "label": "arr2",
        "kind": 5,
        "importPath": "week3.more_data",
        "description": "week3.more_data",
        "peekOfCode": "arr2 = np.array([6, 7, 8, 9, 10])\nprint(\"Array 1:\", arr1)\nprint(\"Array 2:\", arr2)\n# Array operations\nprint(\"Sum of arrays:\", arr1 + arr2)\nprint(\"Product of arrays:\", arr1 * arr2)\nprint(\"Mean of Array 1:\", np.mean(arr1))\n# Creating matrices\nmatrix1 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nmatrix2 = np.array([[9, 8, 7], [6, 5, 4], [3, 2, 1]])",
        "detail": "week3.more_data",
        "documentation": {}
    },
    {
        "label": "matrix1",
        "kind": 5,
        "importPath": "week3.more_data",
        "description": "week3.more_data",
        "peekOfCode": "matrix1 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nmatrix2 = np.array([[9, 8, 7], [6, 5, 4], [3, 2, 1]])\nprint(\"\\nMatrix 1:\")\nprint(matrix1)\nprint(\"Matrix 2:\")\nprint(matrix2)\n# Matrix operations\nprint(\"Matrix addition:\")\nprint(matrix1 + matrix2)\nprint(\"Matrix multiplication:\")",
        "detail": "week3.more_data",
        "documentation": {}
    },
    {
        "label": "matrix2",
        "kind": 5,
        "importPath": "week3.more_data",
        "description": "week3.more_data",
        "peekOfCode": "matrix2 = np.array([[9, 8, 7], [6, 5, 4], [3, 2, 1]])\nprint(\"\\nMatrix 1:\")\nprint(matrix1)\nprint(\"Matrix 2:\")\nprint(matrix2)\n# Matrix operations\nprint(\"Matrix addition:\")\nprint(matrix1 + matrix2)\nprint(\"Matrix multiplication:\")\nprint(np.matmul(matrix1, matrix2))",
        "detail": "week3.more_data",
        "documentation": {}
    },
    {
        "label": "normal_dist",
        "kind": 5,
        "importPath": "week3.more_data",
        "description": "week3.more_data",
        "peekOfCode": "normal_dist = np.random.normal(0, 1, 1000)\nprint(normal_dist[:10])  # Print first 10 numbers\n# Matplotlib Examples\nprint(\"\\nMatplotlib Examples:\")\n# Line plot\nx = np.linspace(0, 10, 100)\ny1 = np.sin(x)\ny2 = np.cos(x)\nplt.figure(figsize=(10, 6))\nplt.plot(x, y1, label=\"sin(x)\")",
        "detail": "week3.more_data",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "week3.more_data",
        "description": "week3.more_data",
        "peekOfCode": "x = np.linspace(0, 10, 100)\ny1 = np.sin(x)\ny2 = np.cos(x)\nplt.figure(figsize=(10, 6))\nplt.plot(x, y1, label=\"sin(x)\")\nplt.plot(x, y2, label=\"cos(x)\")\nplt.title(\"Sine and Cosine Functions\")\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.legend()",
        "detail": "week3.more_data",
        "documentation": {}
    },
    {
        "label": "y1",
        "kind": 5,
        "importPath": "week3.more_data",
        "description": "week3.more_data",
        "peekOfCode": "y1 = np.sin(x)\ny2 = np.cos(x)\nplt.figure(figsize=(10, 6))\nplt.plot(x, y1, label=\"sin(x)\")\nplt.plot(x, y2, label=\"cos(x)\")\nplt.title(\"Sine and Cosine Functions\")\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.legend()\nplt.grid(True)",
        "detail": "week3.more_data",
        "documentation": {}
    },
    {
        "label": "y2",
        "kind": 5,
        "importPath": "week3.more_data",
        "description": "week3.more_data",
        "peekOfCode": "y2 = np.cos(x)\nplt.figure(figsize=(10, 6))\nplt.plot(x, y1, label=\"sin(x)\")\nplt.plot(x, y2, label=\"cos(x)\")\nplt.title(\"Sine and Cosine Functions\")\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.legend()\nplt.grid(True)\nplt.show()",
        "detail": "week3.more_data",
        "documentation": {}
    },
    {
        "label": "correlation_matrix",
        "kind": 5,
        "importPath": "week3.more_data",
        "description": "week3.more_data",
        "peekOfCode": "correlation_matrix = csv_df.select_dtypes(include=[np.number]).corr()\nsns.heatmap(correlation_matrix, annot=True, cmap=\"coolwarm\", linewidths=0.5)\nplt.title(\"Correlation Matrix of Numerical Variables\")\nplt.show()\nprint(\"All examples have been executed. Check the generated plots for visual results.\")",
        "detail": "week3.more_data",
        "documentation": {}
    },
    {
        "label": "X_train",
        "kind": 5,
        "importPath": "week4.computer_learning_exp",
        "description": "week4.computer_learning_exp",
        "peekOfCode": "X_train = X_train / 255.0\nX_test = X_test / 255.0\n# Sınıf isimleri\nclass_names = [\n    \"airplane\",\n    \"automobile\",\n    \"bird\",\n    \"cat\",\n    \"deer\",\n    \"dog\",",
        "detail": "week4.computer_learning_exp",
        "documentation": {}
    },
    {
        "label": "X_test",
        "kind": 5,
        "importPath": "week4.computer_learning_exp",
        "description": "week4.computer_learning_exp",
        "peekOfCode": "X_test = X_test / 255.0\n# Sınıf isimleri\nclass_names = [\n    \"airplane\",\n    \"automobile\",\n    \"bird\",\n    \"cat\",\n    \"deer\",\n    \"dog\",\n    \"frog\",",
        "detail": "week4.computer_learning_exp",
        "documentation": {}
    },
    {
        "label": "class_names",
        "kind": 5,
        "importPath": "week4.computer_learning_exp",
        "description": "week4.computer_learning_exp",
        "peekOfCode": "class_names = [\n    \"airplane\",\n    \"automobile\",\n    \"bird\",\n    \"cat\",\n    \"deer\",\n    \"dog\",\n    \"frog\",\n    \"horse\",\n    \"ship\",",
        "detail": "week4.computer_learning_exp",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "week4.computer_learning_exp",
        "description": "week4.computer_learning_exp",
        "peekOfCode": "model = models.Sequential(\n    [\n        layers.Conv2D(32, (3, 3), activation=\"relu\", input_shape=(32, 32, 3)),\n        layers.MaxPooling2D((2, 2)),\n        layers.Conv2D(64, (3, 3), activation=\"relu\"),\n        layers.MaxPooling2D((2, 2)),\n        layers.Conv2D(64, (3, 3), activation=\"relu\"),\n        # Fully connected katmanlar\n        layers.Flatten(),\n        layers.Dense(64, activation=\"relu\"),",
        "detail": "week4.computer_learning_exp",
        "documentation": {}
    },
    {
        "label": "predictions",
        "kind": 5,
        "importPath": "week4.computer_learning_exp",
        "description": "week4.computer_learning_exp",
        "peekOfCode": "predictions = model.predict(X_test)\npredicted_label = class_names[predictions[0].argmax()]\n# Görüntüyü gösterme ve tahmin edilen etiketi yazdırma\nplt.imshow(X_test[0])\nplt.title(f\"Gerçek: {class_names[y_test[0][0]]}, Tahmin: {predicted_label}\")\nplt.show()\n# Kodun Açıklaması:\n# CIFAR-10 Veri Seti: Bu veri seti, 10 sınıfa ait 60,000 adet 32x32 boyutlarında renkli görüntüden oluşur. 50,000'i eğitim, 10,000'i test verisidir.\n# Convolutional Neural Network (CNN): CNN, görüntülerdeki lokal özellikleri öğrenmek için kullanılan bir sinir ağı türüdür. Bu modelde üç adet convolution ve pooling katmanı bulunmaktadır.\n# Girdi Şekli: CNN'de görüntülerin girdi boyutu 32x32 piksel ve 3 kanal (RGB) içerir.",
        "detail": "week4.computer_learning_exp",
        "documentation": {}
    },
    {
        "label": "predicted_label",
        "kind": 5,
        "importPath": "week4.computer_learning_exp",
        "description": "week4.computer_learning_exp",
        "peekOfCode": "predicted_label = class_names[predictions[0].argmax()]\n# Görüntüyü gösterme ve tahmin edilen etiketi yazdırma\nplt.imshow(X_test[0])\nplt.title(f\"Gerçek: {class_names[y_test[0][0]]}, Tahmin: {predicted_label}\")\nplt.show()\n# Kodun Açıklaması:\n# CIFAR-10 Veri Seti: Bu veri seti, 10 sınıfa ait 60,000 adet 32x32 boyutlarında renkli görüntüden oluşur. 50,000'i eğitim, 10,000'i test verisidir.\n# Convolutional Neural Network (CNN): CNN, görüntülerdeki lokal özellikleri öğrenmek için kullanılan bir sinir ağı türüdür. Bu modelde üç adet convolution ve pooling katmanı bulunmaktadır.\n# Girdi Şekli: CNN'de görüntülerin girdi boyutu 32x32 piksel ve 3 kanal (RGB) içerir.\n# Softmax Çıktı Katmanı: Son katmanda 10 sınıfa ait olasılıkları döndüren bir softmax katmanı bulunur.",
        "detail": "week4.computer_learning_exp",
        "documentation": {}
    },
    {
        "label": "base_model",
        "kind": 5,
        "importPath": "week4.computer_learning_exp",
        "description": "week4.computer_learning_exp",
        "peekOfCode": "base_model = ResNet50(weights=\"imagenet\", include_top=False, input_shape=(224, 224, 3))\n# Yeni sınıflandırıcı katmanları ekleme\nx = Flatten()(base_model.output)\nx = Dense(1024, activation=\"relu\")(x)\npredictions = Dense(10, activation=\"softmax\")(x)\n# Yeni modelin oluşturulması\nmodel = Model(inputs=base_model.input, outputs=predictions)\n# Önceden eğitilmiş katmanları dondurma (bunlar eğitilmeyecek)\nfor layer in base_model.layers:\n    layer.trainable = False",
        "detail": "week4.computer_learning_exp",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "week4.computer_learning_exp",
        "description": "week4.computer_learning_exp",
        "peekOfCode": "x = Flatten()(base_model.output)\nx = Dense(1024, activation=\"relu\")(x)\npredictions = Dense(10, activation=\"softmax\")(x)\n# Yeni modelin oluşturulması\nmodel = Model(inputs=base_model.input, outputs=predictions)\n# Önceden eğitilmiş katmanları dondurma (bunlar eğitilmeyecek)\nfor layer in base_model.layers:\n    layer.trainable = False\n# Modelin derlenmesi\nmodel.compile(optimizer=\"adam\", loss=\"categorical_crossentropy\", metrics=[\"accuracy\"])",
        "detail": "week4.computer_learning_exp",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "week4.computer_learning_exp",
        "description": "week4.computer_learning_exp",
        "peekOfCode": "x = Dense(1024, activation=\"relu\")(x)\npredictions = Dense(10, activation=\"softmax\")(x)\n# Yeni modelin oluşturulması\nmodel = Model(inputs=base_model.input, outputs=predictions)\n# Önceden eğitilmiş katmanları dondurma (bunlar eğitilmeyecek)\nfor layer in base_model.layers:\n    layer.trainable = False\n# Modelin derlenmesi\nmodel.compile(optimizer=\"adam\", loss=\"categorical_crossentropy\", metrics=[\"accuracy\"])\n# ImageDataGenerator ile veri artırma (data augmentation)",
        "detail": "week4.computer_learning_exp",
        "documentation": {}
    },
    {
        "label": "predictions",
        "kind": 5,
        "importPath": "week4.computer_learning_exp",
        "description": "week4.computer_learning_exp",
        "peekOfCode": "predictions = Dense(10, activation=\"softmax\")(x)\n# Yeni modelin oluşturulması\nmodel = Model(inputs=base_model.input, outputs=predictions)\n# Önceden eğitilmiş katmanları dondurma (bunlar eğitilmeyecek)\nfor layer in base_model.layers:\n    layer.trainable = False\n# Modelin derlenmesi\nmodel.compile(optimizer=\"adam\", loss=\"categorical_crossentropy\", metrics=[\"accuracy\"])\n# ImageDataGenerator ile veri artırma (data augmentation)\ntrain_datagen = ImageDataGenerator(",
        "detail": "week4.computer_learning_exp",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "week4.computer_learning_exp",
        "description": "week4.computer_learning_exp",
        "peekOfCode": "model = Model(inputs=base_model.input, outputs=predictions)\n# Önceden eğitilmiş katmanları dondurma (bunlar eğitilmeyecek)\nfor layer in base_model.layers:\n    layer.trainable = False\n# Modelin derlenmesi\nmodel.compile(optimizer=\"adam\", loss=\"categorical_crossentropy\", metrics=[\"accuracy\"])\n# ImageDataGenerator ile veri artırma (data augmentation)\ntrain_datagen = ImageDataGenerator(\n    rescale=1.0 / 255,\n    rotation_range=40,",
        "detail": "week4.computer_learning_exp",
        "documentation": {}
    },
    {
        "label": "train_datagen",
        "kind": 5,
        "importPath": "week4.computer_learning_exp",
        "description": "week4.computer_learning_exp",
        "peekOfCode": "train_datagen = ImageDataGenerator(\n    rescale=1.0 / 255,\n    rotation_range=40,\n    width_shift_range=0.2,\n    height_shift_range=0.2,\n    shear_range=0.2,\n    zoom_range=0.2,\n    horizontal_flip=True,\n)\n# Veri seti klasöründen veri yükleme ve model eğitimi",
        "detail": "week4.computer_learning_exp",
        "documentation": {}
    },
    {
        "label": "train_generator",
        "kind": 5,
        "importPath": "week4.computer_learning_exp",
        "description": "week4.computer_learning_exp",
        "peekOfCode": "train_generator = train_datagen.flow_from_directory(\n    \"path_to_train_data\",\n    target_size=(224, 224),\n    batch_size=32,\n    class_mode=\"categorical\",\n)\n# Modeli eğitme\nmodel.fit(train_generator, epochs=10)\n# Bu örnekte ResNet-50'yi kullanarak, görüntü sınıflandırması yapmak için transfer öğrenme yöntemi uygulanmıştır. Model, önceki ImageNet ağırlıklarıyla başlar ve yeni bir problem için ince ayar yapılır.\n# Computer Vision Uygulama Alanları:",
        "detail": "week4.computer_learning_exp",
        "documentation": {}
    },
    {
        "label": "X_train",
        "kind": 5,
        "importPath": "week4.deep_learning_exp",
        "description": "week4.deep_learning_exp",
        "peekOfCode": "X_train = X_train / 255.0\nX_test = X_test / 255.0\n# Verileri düzleştirme (28x28 boyutundaki görüntüler 784 boyutlu bir vektöre çevriliyor)\nX_train = X_train.reshape(-1, 28 * 28)\nX_test = X_test.reshape(-1, 28 * 28)\n# Modelin oluşturulması\nmodel = models.Sequential(\n    [\n        layers.Dense(128, activation=\"relu\", input_shape=(784,)),\n        layers.Dense(64, activation=\"relu\"),",
        "detail": "week4.deep_learning_exp",
        "documentation": {}
    },
    {
        "label": "X_test",
        "kind": 5,
        "importPath": "week4.deep_learning_exp",
        "description": "week4.deep_learning_exp",
        "peekOfCode": "X_test = X_test / 255.0\n# Verileri düzleştirme (28x28 boyutundaki görüntüler 784 boyutlu bir vektöre çevriliyor)\nX_train = X_train.reshape(-1, 28 * 28)\nX_test = X_test.reshape(-1, 28 * 28)\n# Modelin oluşturulması\nmodel = models.Sequential(\n    [\n        layers.Dense(128, activation=\"relu\", input_shape=(784,)),\n        layers.Dense(64, activation=\"relu\"),\n        layers.Dense(10, activation=\"softmax\"),  # 10 sınıf (0-9 arası rakamlar)",
        "detail": "week4.deep_learning_exp",
        "documentation": {}
    },
    {
        "label": "X_train",
        "kind": 5,
        "importPath": "week4.deep_learning_exp",
        "description": "week4.deep_learning_exp",
        "peekOfCode": "X_train = X_train.reshape(-1, 28 * 28)\nX_test = X_test.reshape(-1, 28 * 28)\n# Modelin oluşturulması\nmodel = models.Sequential(\n    [\n        layers.Dense(128, activation=\"relu\", input_shape=(784,)),\n        layers.Dense(64, activation=\"relu\"),\n        layers.Dense(10, activation=\"softmax\"),  # 10 sınıf (0-9 arası rakamlar)\n    ]\n)",
        "detail": "week4.deep_learning_exp",
        "documentation": {}
    },
    {
        "label": "X_test",
        "kind": 5,
        "importPath": "week4.deep_learning_exp",
        "description": "week4.deep_learning_exp",
        "peekOfCode": "X_test = X_test.reshape(-1, 28 * 28)\n# Modelin oluşturulması\nmodel = models.Sequential(\n    [\n        layers.Dense(128, activation=\"relu\", input_shape=(784,)),\n        layers.Dense(64, activation=\"relu\"),\n        layers.Dense(10, activation=\"softmax\"),  # 10 sınıf (0-9 arası rakamlar)\n    ]\n)\n# Modeli derleme (optimizasyon, kayıp fonksiyonu ve değerlendirme metriği seçilir)",
        "detail": "week4.deep_learning_exp",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "week4.deep_learning_exp",
        "description": "week4.deep_learning_exp",
        "peekOfCode": "model = models.Sequential(\n    [\n        layers.Dense(128, activation=\"relu\", input_shape=(784,)),\n        layers.Dense(64, activation=\"relu\"),\n        layers.Dense(10, activation=\"softmax\"),  # 10 sınıf (0-9 arası rakamlar)\n    ]\n)\n# Modeli derleme (optimizasyon, kayıp fonksiyonu ve değerlendirme metriği seçilir)\nmodel.compile(\n    optimizer=\"adam\", loss=\"sparse_categorical_crossentropy\", metrics=[\"accuracy\"]",
        "detail": "week4.deep_learning_exp",
        "documentation": {}
    },
    {
        "label": "predictions",
        "kind": 5,
        "importPath": "week4.deep_learning_exp",
        "description": "week4.deep_learning_exp",
        "peekOfCode": "predictions = model.predict(X_test)\npredicted_label = np.argmax(predictions[0])\nprint(f\"Tahmin edilen etiket: {predicted_label}\")\n# Kodun Açıklaması:\n# Veri Seti: MNIST veri seti, el yazısı rakamları içerir. Bu veri setinde her rakam 28x28 piksel boyutunda gri tonlamalı görüntülerden oluşur.\n# Model: Üç katmandan oluşan basit bir sinir ağı kurulmuştur:\n# İlk gizli katmanda 128 nöron vardır ve aktivasyon fonksiyonu olarak ReLU kullanılır.\n# İkinci gizli katmanda 64 nöron vardır ve yine ReLU kullanılır.\n# Son katman, 10 sınıf (0-9 arası rakamlar) için softmax fonksiyonunu kullanır.\n# Loss Function: sparse_categorical_crossentropy kullanılmıştır, çünkü sınıflandırma problemi vardır ve etiketler tam sayıdır.",
        "detail": "week4.deep_learning_exp",
        "documentation": {}
    },
    {
        "label": "predicted_label",
        "kind": 5,
        "importPath": "week4.deep_learning_exp",
        "description": "week4.deep_learning_exp",
        "peekOfCode": "predicted_label = np.argmax(predictions[0])\nprint(f\"Tahmin edilen etiket: {predicted_label}\")\n# Kodun Açıklaması:\n# Veri Seti: MNIST veri seti, el yazısı rakamları içerir. Bu veri setinde her rakam 28x28 piksel boyutunda gri tonlamalı görüntülerden oluşur.\n# Model: Üç katmandan oluşan basit bir sinir ağı kurulmuştur:\n# İlk gizli katmanda 128 nöron vardır ve aktivasyon fonksiyonu olarak ReLU kullanılır.\n# İkinci gizli katmanda 64 nöron vardır ve yine ReLU kullanılır.\n# Son katman, 10 sınıf (0-9 arası rakamlar) için softmax fonksiyonunu kullanır.\n# Loss Function: sparse_categorical_crossentropy kullanılmıştır, çünkü sınıflandırma problemi vardır ve etiketler tam sayıdır.\n# Optimizer: Adam optimizasyon algoritması kullanılmıştır.",
        "detail": "week4.deep_learning_exp",
        "documentation": {}
    },
    {
        "label": "iris",
        "kind": 5,
        "importPath": "week4.flower_classification",
        "description": "week4.flower_classification",
        "peekOfCode": "iris = tf.keras.datasets.iris\n(x_train, y_train), (x_test, y_test) = iris.load_data()\n# Normalisera indata\n# viktigt för att få alla features i samma skala\nx_train, x_test = x_train / np.max(x_train), x_test / np.max(x_test)\n# Konvertera etiketter till one-hot encoding\n# Nödvändigt för fler flerklass-klassificering\ny_train = tf.keras.utils.to_categorically(y_train)\ny_test = tf.keras.utils.to_categorically(y_test)\n# Skapa en enkel sekventiell modell",
        "detail": "week4.flower_classification",
        "documentation": {}
    },
    {
        "label": "y_train",
        "kind": 5,
        "importPath": "week4.flower_classification",
        "description": "week4.flower_classification",
        "peekOfCode": "y_train = tf.keras.utils.to_categorically(y_train)\ny_test = tf.keras.utils.to_categorically(y_test)\n# Skapa en enkel sekventiell modell\n# Grundläggande typ av neural network, varje lager kopplat till nästa\nmodel = tf.keras.models.Sequential(\n    [\n        tf.keras.layers.Dense(10, activatoin=\"relu\", input_shape=(4,)),\n        tf.keras.layers.Dense(\n            10,\n            activatoin=\"relu\",",
        "detail": "week4.flower_classification",
        "documentation": {}
    },
    {
        "label": "y_test",
        "kind": 5,
        "importPath": "week4.flower_classification",
        "description": "week4.flower_classification",
        "peekOfCode": "y_test = tf.keras.utils.to_categorically(y_test)\n# Skapa en enkel sekventiell modell\n# Grundläggande typ av neural network, varje lager kopplat till nästa\nmodel = tf.keras.models.Sequential(\n    [\n        tf.keras.layers.Dense(10, activatoin=\"relu\", input_shape=(4,)),\n        tf.keras.layers.Dense(\n            10,\n            activatoin=\"relu\",\n        ),",
        "detail": "week4.flower_classification",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "week4.flower_classification",
        "description": "week4.flower_classification",
        "peekOfCode": "model = tf.keras.models.Sequential(\n    [\n        tf.keras.layers.Dense(10, activatoin=\"relu\", input_shape=(4,)),\n        tf.keras.layers.Dense(\n            10,\n            activatoin=\"relu\",\n        ),\n        tf.keras.layers.Dense(\n            10,\n            activatoin=\"softmax\",",
        "detail": "week4.flower_classification",
        "documentation": {}
    },
    {
        "label": "history",
        "kind": 5,
        "importPath": "week4.flower_classification",
        "description": "week4.flower_classification",
        "peekOfCode": "history = model.fit(x_train, y_train, epochs=50, validation_split=0.2, verbose=0)\n# Utvärdera modellen på testdata\ntest_loss, test_acc = model.evaluate(x_test, y_test, verbose=2)\nprint(f\"Test Accuracy: {test_acc}\")\n# Visualisera träningshistorik\nplt.figure(figsize=(12, 4))\n# Plot träningsnoggrannhet och valideringsnoggrannhet\nplt.subplot(1, 2, 1)\nplt.plot(history.history[\"accuracy\"], label=\"Training Accuracy\")\nplt.plot(history.history[\"val_accuracy\"], label=\"Validation Accuracy\")",
        "detail": "week4.flower_classification",
        "documentation": {}
    },
    {
        "label": "sample_predictions",
        "kind": 5,
        "importPath": "week4.flower_classification",
        "description": "week4.flower_classification",
        "peekOfCode": "sample_predictions = model.predict(x_test[:3])\nprint(\"\\nSample predictions:\")\nfor i, pred in enumerate(sample_predictions):\n    print(f\"Example {i+1}: {pred}\")\n    print(f\"Predicted class: {np.argmax(pred)}\")\n    print(f\"Actual class: {np.argmax(y_test[i])}\")\n    print()",
        "detail": "week4.flower_classification",
        "documentation": {}
    },
    {
        "label": "stop_words",
        "kind": 5,
        "importPath": "week4.nlp_learning_exp",
        "description": "week4.nlp_learning_exp",
        "peekOfCode": "stop_words = stopwords.words('english')\n# Veri seti: Basit bir olumlu ve olumsuz cümleler listesi\ntexts = [\n    \"I love this product, it is amazing!\",\n    \"This is the worst experience I've ever had.\",\n    \"I feel so happy using this service.\",\n    \"This product is terrible and disappointing.\",\n    \"Best purchase I've made, totally worth it!\",\n    \"Not satisfied at all, I want a refund.\",\n    \"The quality is excellent and I highly recommend it.\",",
        "detail": "week4.nlp_learning_exp",
        "documentation": {}
    },
    {
        "label": "texts",
        "kind": 5,
        "importPath": "week4.nlp_learning_exp",
        "description": "week4.nlp_learning_exp",
        "peekOfCode": "texts = [\n    \"I love this product, it is amazing!\",\n    \"This is the worst experience I've ever had.\",\n    \"I feel so happy using this service.\",\n    \"This product is terrible and disappointing.\",\n    \"Best purchase I've made, totally worth it!\",\n    \"Not satisfied at all, I want a refund.\",\n    \"The quality is excellent and I highly recommend it.\",\n    \"Awful service, never coming back again.\"\n]",
        "detail": "week4.nlp_learning_exp",
        "documentation": {}
    },
    {
        "label": "labels",
        "kind": 5,
        "importPath": "week4.nlp_learning_exp",
        "description": "week4.nlp_learning_exp",
        "peekOfCode": "labels = [1, 0, 1, 0, 1, 0, 1, 0]\n# TF-IDF ve Naive Bayes sınıflandırıcıyı içeren bir pipeline oluşturma\nmodel = make_pipeline(TfidfVectorizer(stop_words=stop_words), MultinomialNB())\n# Veriyi eğitim ve test setlerine bölme\nX_train, X_test, y_train, y_test = train_test_split(texts, labels, test_size=0.25, random_state=42)\n# Modeli eğitme\nmodel.fit(X_train, y_train)\n# Test verisi üzerinde tahmin yapma\ny_pred = model.predict(X_test)\n# Model doğruluğunu hesaplama",
        "detail": "week4.nlp_learning_exp",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "week4.nlp_learning_exp",
        "description": "week4.nlp_learning_exp",
        "peekOfCode": "model = make_pipeline(TfidfVectorizer(stop_words=stop_words), MultinomialNB())\n# Veriyi eğitim ve test setlerine bölme\nX_train, X_test, y_train, y_test = train_test_split(texts, labels, test_size=0.25, random_state=42)\n# Modeli eğitme\nmodel.fit(X_train, y_train)\n# Test verisi üzerinde tahmin yapma\ny_pred = model.predict(X_test)\n# Model doğruluğunu hesaplama\naccuracy = accuracy_score(y_test, y_pred)\nprint(f\"Model Doğruluğu: {accuracy * 100:.2f}%\")",
        "detail": "week4.nlp_learning_exp",
        "documentation": {}
    },
    {
        "label": "y_pred",
        "kind": 5,
        "importPath": "week4.nlp_learning_exp",
        "description": "week4.nlp_learning_exp",
        "peekOfCode": "y_pred = model.predict(X_test)\n# Model doğruluğunu hesaplama\naccuracy = accuracy_score(y_test, y_pred)\nprint(f\"Model Doğruluğu: {accuracy * 100:.2f}%\")\n# Test verilerinin tahmin edilen etiketleri\nfor i, text in enumerate(X_test):\n    print(f\"Metin: {text}\\nGerçek Etiket: {y_test[i]} - Tahmin Edilen Etiket: {y_pred[i]}\")\n# Kodun Açıklaması:\n# Veri Seti: Basit bir olumlu ve olumsuz cümlelerden oluşan küçük bir veri seti kullanıyoruz.\n# TF-IDF Vektörleştirme: TfidfVectorizer ile metinleri sayısal vektörlere dönüştürüyoruz. Bu yöntem, her kelimenin bir belgede ne kadar sık geçtiğini hesaplayarak metni temsil eder.",
        "detail": "week4.nlp_learning_exp",
        "documentation": {}
    },
    {
        "label": "accuracy",
        "kind": 5,
        "importPath": "week4.nlp_learning_exp",
        "description": "week4.nlp_learning_exp",
        "peekOfCode": "accuracy = accuracy_score(y_test, y_pred)\nprint(f\"Model Doğruluğu: {accuracy * 100:.2f}%\")\n# Test verilerinin tahmin edilen etiketleri\nfor i, text in enumerate(X_test):\n    print(f\"Metin: {text}\\nGerçek Etiket: {y_test[i]} - Tahmin Edilen Etiket: {y_pred[i]}\")\n# Kodun Açıklaması:\n# Veri Seti: Basit bir olumlu ve olumsuz cümlelerden oluşan küçük bir veri seti kullanıyoruz.\n# TF-IDF Vektörleştirme: TfidfVectorizer ile metinleri sayısal vektörlere dönüştürüyoruz. Bu yöntem, her kelimenin bir belgede ne kadar sık geçtiğini hesaplayarak metni temsil eder.\n# Naive Bayes: MultinomialNB sınıflandırıcısı, vektörleştirilen metinleri kullanarak sınıflandırma yapar.\n# Model Eğitimi ve Testi: Veriyi eğitim ve test kümelerine böldükten sonra model eğitilir. Ardından test verisi üzerinde tahminler yapılır.",
        "detail": "week4.nlp_learning_exp",
        "documentation": {}
    },
    {
        "label": "choose_action",
        "kind": 2,
        "importPath": "week4.reinforcement_learning_exp",
        "description": "week4.reinforcement_learning_exp",
        "peekOfCode": "def choose_action(position):\n    \"\"\"Epsilon-greedy stratejisiyle aksiyon seçimi.\"\"\"\n    if random.uniform(0, 1) < epsilon:\n        # Rastgele aksiyon (keşfetme)\n        return random.choice(actions)\n    else:\n        # En iyi aksiyon (kazanma)\n        state_actions = Q_table[position[0], position[1], :]\n        return actions[np.argmax(state_actions)]\ndef take_action(position, action):",
        "detail": "week4.reinforcement_learning_exp",
        "documentation": {}
    },
    {
        "label": "take_action",
        "kind": 2,
        "importPath": "week4.reinforcement_learning_exp",
        "description": "week4.reinforcement_learning_exp",
        "peekOfCode": "def take_action(position, action):\n    \"\"\"Verilen aksiyona göre ajanı hareket ettirme.\"\"\"\n    new_position = position.copy()\n    if action == 'up' and position[0] > 0:\n        new_position[0] -= 1\n    elif action == 'down' and position[0] < 4:\n        new_position[0] += 1\n    elif action == 'left' and position[1] > 0:\n        new_position[1] -= 1\n    elif action == 'right' and position[1] < 4:",
        "detail": "week4.reinforcement_learning_exp",
        "documentation": {}
    },
    {
        "label": "get_reward",
        "kind": 2,
        "importPath": "week4.reinforcement_learning_exp",
        "description": "week4.reinforcement_learning_exp",
        "peekOfCode": "def get_reward(position):\n    \"\"\"Ajanın ödülünü hesaplama.\"\"\"\n    if position == [4, 4]:\n        return 10\n    else:\n        return -0.1\n# Q-Learning algoritması\nfor episode in range(1000):\n    agent_position = [0, 0]  # Ajan her seferinde başlangıç noktasından başlar\n    while agent_position != [4, 4]:  # Ödül noktasına ulaşana kadar",
        "detail": "week4.reinforcement_learning_exp",
        "documentation": {}
    },
    {
        "label": "environment",
        "kind": 5,
        "importPath": "week4.reinforcement_learning_exp",
        "description": "week4.reinforcement_learning_exp",
        "peekOfCode": "environment = np.zeros((5, 5))\n# Ödül noktası (4, 4)\nenvironment[4, 4] = 10  # Ödül\n# Hareket seçenekleri: yukarı, aşağı, sola, sağa\nactions = ['up', 'down', 'left', 'right']\n# Q-table (Q-değerleri saklanacak)\nQ_table = np.zeros((5, 5, len(actions)))\n# Öğrenme parametreleri\nalpha = 0.1  # Öğrenme hızı\ngamma = 0.9  # Gelecekteki ödüllere ne kadar değer verdiğimizi belirler",
        "detail": "week4.reinforcement_learning_exp",
        "documentation": {}
    },
    {
        "label": "actions",
        "kind": 5,
        "importPath": "week4.reinforcement_learning_exp",
        "description": "week4.reinforcement_learning_exp",
        "peekOfCode": "actions = ['up', 'down', 'left', 'right']\n# Q-table (Q-değerleri saklanacak)\nQ_table = np.zeros((5, 5, len(actions)))\n# Öğrenme parametreleri\nalpha = 0.1  # Öğrenme hızı\ngamma = 0.9  # Gelecekteki ödüllere ne kadar değer verdiğimizi belirler\nepsilon = 0.8  # Keşfetme oranı (başlangıçta keşfetmeye daha çok odaklanır)\n# Ajanın başlangıç pozisyonu\nagent_position = [0, 0]\ndef choose_action(position):",
        "detail": "week4.reinforcement_learning_exp",
        "documentation": {}
    },
    {
        "label": "Q_table",
        "kind": 5,
        "importPath": "week4.reinforcement_learning_exp",
        "description": "week4.reinforcement_learning_exp",
        "peekOfCode": "Q_table = np.zeros((5, 5, len(actions)))\n# Öğrenme parametreleri\nalpha = 0.1  # Öğrenme hızı\ngamma = 0.9  # Gelecekteki ödüllere ne kadar değer verdiğimizi belirler\nepsilon = 0.8  # Keşfetme oranı (başlangıçta keşfetmeye daha çok odaklanır)\n# Ajanın başlangıç pozisyonu\nagent_position = [0, 0]\ndef choose_action(position):\n    \"\"\"Epsilon-greedy stratejisiyle aksiyon seçimi.\"\"\"\n    if random.uniform(0, 1) < epsilon:",
        "detail": "week4.reinforcement_learning_exp",
        "documentation": {}
    },
    {
        "label": "alpha",
        "kind": 5,
        "importPath": "week4.reinforcement_learning_exp",
        "description": "week4.reinforcement_learning_exp",
        "peekOfCode": "alpha = 0.1  # Öğrenme hızı\ngamma = 0.9  # Gelecekteki ödüllere ne kadar değer verdiğimizi belirler\nepsilon = 0.8  # Keşfetme oranı (başlangıçta keşfetmeye daha çok odaklanır)\n# Ajanın başlangıç pozisyonu\nagent_position = [0, 0]\ndef choose_action(position):\n    \"\"\"Epsilon-greedy stratejisiyle aksiyon seçimi.\"\"\"\n    if random.uniform(0, 1) < epsilon:\n        # Rastgele aksiyon (keşfetme)\n        return random.choice(actions)",
        "detail": "week4.reinforcement_learning_exp",
        "documentation": {}
    },
    {
        "label": "gamma",
        "kind": 5,
        "importPath": "week4.reinforcement_learning_exp",
        "description": "week4.reinforcement_learning_exp",
        "peekOfCode": "gamma = 0.9  # Gelecekteki ödüllere ne kadar değer verdiğimizi belirler\nepsilon = 0.8  # Keşfetme oranı (başlangıçta keşfetmeye daha çok odaklanır)\n# Ajanın başlangıç pozisyonu\nagent_position = [0, 0]\ndef choose_action(position):\n    \"\"\"Epsilon-greedy stratejisiyle aksiyon seçimi.\"\"\"\n    if random.uniform(0, 1) < epsilon:\n        # Rastgele aksiyon (keşfetme)\n        return random.choice(actions)\n    else:",
        "detail": "week4.reinforcement_learning_exp",
        "documentation": {}
    },
    {
        "label": "epsilon",
        "kind": 5,
        "importPath": "week4.reinforcement_learning_exp",
        "description": "week4.reinforcement_learning_exp",
        "peekOfCode": "epsilon = 0.8  # Keşfetme oranı (başlangıçta keşfetmeye daha çok odaklanır)\n# Ajanın başlangıç pozisyonu\nagent_position = [0, 0]\ndef choose_action(position):\n    \"\"\"Epsilon-greedy stratejisiyle aksiyon seçimi.\"\"\"\n    if random.uniform(0, 1) < epsilon:\n        # Rastgele aksiyon (keşfetme)\n        return random.choice(actions)\n    else:\n        # En iyi aksiyon (kazanma)",
        "detail": "week4.reinforcement_learning_exp",
        "documentation": {}
    },
    {
        "label": "agent_position",
        "kind": 5,
        "importPath": "week4.reinforcement_learning_exp",
        "description": "week4.reinforcement_learning_exp",
        "peekOfCode": "agent_position = [0, 0]\ndef choose_action(position):\n    \"\"\"Epsilon-greedy stratejisiyle aksiyon seçimi.\"\"\"\n    if random.uniform(0, 1) < epsilon:\n        # Rastgele aksiyon (keşfetme)\n        return random.choice(actions)\n    else:\n        # En iyi aksiyon (kazanma)\n        state_actions = Q_table[position[0], position[1], :]\n        return actions[np.argmax(state_actions)]",
        "detail": "week4.reinforcement_learning_exp",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "week4.supervised_learning_exp",
        "description": "week4.supervised_learning_exp",
        "peekOfCode": "data = {\n    \"Feature1\": [2, 3, 5, 7, 8, 10, 12, 15, 18, 20],\n    \"Feature2\": [1, 4, 5, 8, 10, 13, 14, 16, 17, 19],\n    \"Label\": [0, 0, 0, 1, 0, 1, 1, 1, 1, 1],\n}\ndf = pd.DataFrame(data)\n# entry (X) ve output (y) variables\nX = df[[\"Feature1\", \"Feature2\"]]\ny = df[\"Label\"]\n# splitting education and test set",
        "detail": "week4.supervised_learning_exp",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "week4.supervised_learning_exp",
        "description": "week4.supervised_learning_exp",
        "peekOfCode": "df = pd.DataFrame(data)\n# entry (X) ve output (y) variables\nX = df[[\"Feature1\", \"Feature2\"]]\ny = df[\"Label\"]\n# splitting education and test set\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.3, random_state=42\n)\n# Model creating and training\nmodel = LogisticRegression()",
        "detail": "week4.supervised_learning_exp",
        "documentation": {}
    },
    {
        "label": "X",
        "kind": 5,
        "importPath": "week4.supervised_learning_exp",
        "description": "week4.supervised_learning_exp",
        "peekOfCode": "X = df[[\"Feature1\", \"Feature2\"]]\ny = df[\"Label\"]\n# splitting education and test set\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.3, random_state=42\n)\n# Model creating and training\nmodel = LogisticRegression()\nmodel.fit(X_train, y_train)\n# guessing",
        "detail": "week4.supervised_learning_exp",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": "week4.supervised_learning_exp",
        "description": "week4.supervised_learning_exp",
        "peekOfCode": "y = df[\"Label\"]\n# splitting education and test set\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.3, random_state=42\n)\n# Model creating and training\nmodel = LogisticRegression()\nmodel.fit(X_train, y_train)\n# guessing\ny_pred = model.predict(X_test)",
        "detail": "week4.supervised_learning_exp",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "week4.supervised_learning_exp",
        "description": "week4.supervised_learning_exp",
        "peekOfCode": "model = LogisticRegression()\nmodel.fit(X_train, y_train)\n# guessing\ny_pred = model.predict(X_test)\n# model accuracy calculating\naccuracy = accuracy_score(y_test, y_pred)\nprint(\"Model accuracy: {:.2f}%\".format(accuracy * 100))",
        "detail": "week4.supervised_learning_exp",
        "documentation": {}
    },
    {
        "label": "y_pred",
        "kind": 5,
        "importPath": "week4.supervised_learning_exp",
        "description": "week4.supervised_learning_exp",
        "peekOfCode": "y_pred = model.predict(X_test)\n# model accuracy calculating\naccuracy = accuracy_score(y_test, y_pred)\nprint(\"Model accuracy: {:.2f}%\".format(accuracy * 100))",
        "detail": "week4.supervised_learning_exp",
        "documentation": {}
    },
    {
        "label": "accuracy",
        "kind": 5,
        "importPath": "week4.supervised_learning_exp",
        "description": "week4.supervised_learning_exp",
        "peekOfCode": "accuracy = accuracy_score(y_test, y_pred)\nprint(\"Model accuracy: {:.2f}%\".format(accuracy * 100))",
        "detail": "week4.supervised_learning_exp",
        "documentation": {}
    },
    {
        "label": "kmeans",
        "kind": 5,
        "importPath": "week4.unsupervised_learning_exp",
        "description": "week4.unsupervised_learning_exp",
        "peekOfCode": "kmeans = KMeans(n_clusters=4)\nkmeans.fit(X)\n# to find which models with predict\ny_kmeans = kmeans.predict(X)\n# get center of cluster\ncenters = kmeans.cluster_centers_\n# make visualize\nplt.scatter(X[:, 0], X[:, 1], c=y_kmeans, s=50, cmap='viridis')\nplt.scatter(centers[:, 0], centers[:, 1], c='red', s=200, alpha=0.75, marker='X')\nplt.title('K-Means results')",
        "detail": "week4.unsupervised_learning_exp",
        "documentation": {}
    },
    {
        "label": "y_kmeans",
        "kind": 5,
        "importPath": "week4.unsupervised_learning_exp",
        "description": "week4.unsupervised_learning_exp",
        "peekOfCode": "y_kmeans = kmeans.predict(X)\n# get center of cluster\ncenters = kmeans.cluster_centers_\n# make visualize\nplt.scatter(X[:, 0], X[:, 1], c=y_kmeans, s=50, cmap='viridis')\nplt.scatter(centers[:, 0], centers[:, 1], c='red', s=200, alpha=0.75, marker='X')\nplt.title('K-Means results')\nplt.show()",
        "detail": "week4.unsupervised_learning_exp",
        "documentation": {}
    },
    {
        "label": "centers",
        "kind": 5,
        "importPath": "week4.unsupervised_learning_exp",
        "description": "week4.unsupervised_learning_exp",
        "peekOfCode": "centers = kmeans.cluster_centers_\n# make visualize\nplt.scatter(X[:, 0], X[:, 1], c=y_kmeans, s=50, cmap='viridis')\nplt.scatter(centers[:, 0], centers[:, 1], c='red', s=200, alpha=0.75, marker='X')\nplt.title('K-Means results')\nplt.show()",
        "detail": "week4.unsupervised_learning_exp",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "week4.untitled12",
        "description": "week4.untitled12",
        "peekOfCode": "x = np.array([-7.0, -4.0, -1.0, 2.0, 5.0, 8.0, 11.0, 14.0])\ny = np.array([3.0, 6.0, 9.0, 12.0, 15.0, 18.0, 21.0, 24.0])\n# visualisera min data\nplt.scatter(x, y)\n\"\"\"Bygga en modell som förutspår datan utifrån olika värden, t.ex  17, 20, 27 etc.\n\"\"\"\nx.ndim\n\"\"\"STEG FÖR ATT BYGGA EN MODELL i tensorflow\n1.   Create\n2.   Compile",
        "detail": "week4.untitled12",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": "week4.untitled12",
        "description": "week4.untitled12",
        "peekOfCode": "y = np.array([3.0, 6.0, 9.0, 12.0, 15.0, 18.0, 21.0, 24.0])\n# visualisera min data\nplt.scatter(x, y)\n\"\"\"Bygga en modell som förutspår datan utifrån olika värden, t.ex  17, 20, 27 etc.\n\"\"\"\nx.ndim\n\"\"\"STEG FÖR ATT BYGGA EN MODELL i tensorflow\n1.   Create\n2.   Compile\n3.   Fit",
        "detail": "week4.untitled12",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "week4.untitled12",
        "description": "week4.untitled12",
        "peekOfCode": "model = tf.keras.Sequential([tf.keras.layers.Dense(1)])  # output Layer\n# Step2.  Compile\nmodel.compile(\n    loss=tf.keras.losses.mae,\n    optimizer=tf.keras.optimizers.SGD(),  # hur modellen förbättras\n    metrics=[\"mae\"],\n)\n# Step3.  Fit\nmodel.fit(\n    tf.expand_dims(x, axis=-1), y, epochs=50",
        "detail": "week4.untitled12",
        "documentation": {}
    },
    {
        "label": "y_pred",
        "kind": 5,
        "importPath": "week4.untitled12",
        "description": "week4.untitled12",
        "peekOfCode": "y_pred = model.predict(np.array([49]))\ny_pred\n\"\"\"IMPROVE MODEL\nCREATE\n1.   More layers\n2.   More hidden units\n3.   Change Activation function\nCOMPILE\n1.   Optimization function\n2.   Learning rate",
        "detail": "week4.untitled12",
        "documentation": {}
    },
    {
        "label": "model2",
        "kind": 5,
        "importPath": "week4.untitled12",
        "description": "week4.untitled12",
        "peekOfCode": "model2 = tf.keras.Sequential(\n    [\n        tf.keras.layers.Dense(50, activation=None),\n        tf.keras.layers.Dense(1),  # output Layer\n    ]\n)\n# Step2.  Compile\nmodel2.compile(\n    loss=tf.keras.losses.mae,\n    optimizer=tf.keras.optimizers.Adam(0.01),  # hur modellen förbättras",
        "detail": "week4.untitled12",
        "documentation": {}
    },
    {
        "label": "y_pred",
        "kind": 5,
        "importPath": "week4.untitled12",
        "description": "week4.untitled12",
        "peekOfCode": "y_pred = model2.predict(np.array([49]))\ny_pred",
        "detail": "week4.untitled12",
        "documentation": {}
    },
    {
        "label": "ResourceManager",
        "kind": 6,
        "importPath": "week6.exp.resourceManagerAI",
        "description": "week6.exp.resourceManagerAI",
        "peekOfCode": "class ResourceManager(gym.Env):\n    \"\"\"\n    Miljö där en agent ska hantera resurser (t.ex. serverkapacitet)\n    för att möta varierande efterfrågan till lägsta möjliga kostnad.\n    \"\"\"\n    def __init__(self):\n        # Tillstånd: (nuvarande_kapacitet, nuvarande_efterfrågan)\n        self.observation_space = gym.spaces.Discrete(50)  # 5 kapacitetsnivåer * 10 efterfrågansnivåer\n        # Handlingar: minska kapacitet (-1), behåll (0), öka kapacitet (+1)\n        self.action_space = gym.spaces.Discrete(3)",
        "detail": "week6.exp.resourceManagerAI",
        "documentation": {}
    },
    {
        "label": "train_resource_manager",
        "kind": 2,
        "importPath": "week6.exp.resourceManagerAI",
        "description": "week6.exp.resourceManagerAI",
        "peekOfCode": "def train_resource_manager(episodes=1000):\n    \"\"\"\n    Tränar en Q-learning agent för ResourceManager-miljön\n    \"\"\"\n    env = ResourceManager()\n    # Initialisera Q-tabell\n    q_table = defaultdict(lambda: np.zeros(3))  # 3 möjliga handlingar\n    # Hyperparametrar\n    learning_rate = 0.1\n    discount_factor = 0.95",
        "detail": "week6.exp.resourceManagerAI",
        "documentation": {}
    },
    {
        "label": "SimpleTaxi",
        "kind": 6,
        "importPath": "week6.exp.taxiDriverAI",
        "description": "week6.exp.taxiDriverAI",
        "peekOfCode": "class SimpleTaxi(gym.Env):\n    \"\"\"\n    Enkel taxivärld där en taxi ska plocka upp en passagerare och lämna av den.\n    Världen är ett 5x5 rutnät med fyra möjliga upphämtningsplatser (R, G, B, Y).\n    \"\"\"\n    def __init__(self):\n        # Världen är 5x5, taxi kan vara på vilken ruta som helst\n        # För varje ruta kan passageraren vara på 4 olika platser eller i taxin\n        # Passageraren ska till någon av de 4 platserna\n        self.observation_space = gym.spaces.Discrete(5 * 5 * 5 * 4)",
        "detail": "week6.exp.taxiDriverAI",
        "documentation": {}
    },
    {
        "label": "visualize_taxi",
        "kind": 2,
        "importPath": "week6.exp.taxiDriverAI",
        "description": "week6.exp.taxiDriverAI",
        "peekOfCode": "def visualize_taxi(env):\n    \"\"\"\n    Skapar en textbaserad visualisering av taxi-miljön\n    \"\"\"\n    # Skapa en representation av världen\n    world = [['░' for _ in range(5)] for _ in range(5)]\n    # Markera platserna\n    locations = {\n        0: 'R',  # Röd plats\n        1: 'G',  # Grön plats",
        "detail": "week6.exp.taxiDriverAI",
        "documentation": {}
    },
    {
        "label": "train_taxi_driver",
        "kind": 2,
        "importPath": "week6.exp.taxiDriverAI",
        "description": "week6.exp.taxiDriverAI",
        "peekOfCode": "def train_taxi_driver(episodes=2000, render=False):  # Öka antal episoder\n    \"\"\"\n    Tränar en Q-learning agent för taxi-miljön med förbättrade parametrar\n    \"\"\"\n    env = SimpleTaxi()\n    # Initialisera Q-tabell med små slumpmässiga värden istället för nollor\n    q_table = defaultdict(lambda: np.random.uniform(low=-1, high=1, size=6))\n    # Justerade hyperparametrar\n    learning_rate = 0.15\n    discount_factor = 0.99  # Öka för att värdera framtida belöningar högre",
        "detail": "week6.exp.taxiDriverAI",
        "documentation": {}
    },
    {
        "label": "run_trained_taxi",
        "kind": 2,
        "importPath": "week6.exp.taxiDriverAI",
        "description": "week6.exp.taxiDriverAI",
        "peekOfCode": "def run_trained_taxi(q_table, episodes=5):\n    \"\"\"\n    Kör den tränade taxin några episoder för demonstration\n    \"\"\"\n    env = SimpleTaxi()\n    for episode in range(episodes):\n        state, _ = env.reset()\n        total_reward = 0\n        steps = 0\n        print(f\"\\nEpisod {episode + 1}\")",
        "detail": "week6.exp.taxiDriverAI",
        "documentation": {}
    },
    {
        "label": "url",
        "kind": 5,
        "importPath": "week6.project",
        "description": "week6.project",
        "peekOfCode": "url = \"https://raw.githubusercontent.com/sachin365123/CSV-files-for-Data-Science-and-Machine-Learning/refs/heads/main/car.csv\"\ndf = pd.read_csv(url)\n# Grundläggande dataanalys\nprint(\"Dataset Information:\")\nprint(\"-\" * 50)\nprint(\"\\nDataset Shape:\", df.shape)\nprint(\"\\nColumns:\", df.columns.tolist())\nprint(\"\\nData Types:\")\nprint(df.dtypes)\nprint(\"\\nNull Values:\")",
        "detail": "week6.project",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "week6.project",
        "description": "week6.project",
        "peekOfCode": "df = pd.read_csv(url)\n# Grundläggande dataanalys\nprint(\"Dataset Information:\")\nprint(\"-\" * 50)\nprint(\"\\nDataset Shape:\", df.shape)\nprint(\"\\nColumns:\", df.columns.tolist())\nprint(\"\\nData Types:\")\nprint(df.dtypes)\nprint(\"\\nNull Values:\")\nprint(df.isnull().sum())",
        "detail": "week6.project",
        "documentation": {}
    },
    {
        "label": "le",
        "kind": 5,
        "importPath": "week6.project",
        "description": "week6.project",
        "peekOfCode": "le = LabelEncoder()\ndf_encoded = df.copy()\ncategorical_columns = ['Car_Name', 'Fuel_Type', 'Seller_Type', 'Transmission', 'Owner']\nfor col in categorical_columns:\n    df_encoded[col] = le.fit_transform(df_encoded[col])\n# Visa korrelationsmatris\nplt.figure(figsize=(12, 8))\nsns.heatmap(df_encoded.corr(), annot=True, cmap='coolwarm', fmt='.2f')\nplt.title('Correlation Matrix')\nplt.tight_layout()",
        "detail": "week6.project",
        "documentation": {}
    },
    {
        "label": "df_encoded",
        "kind": 5,
        "importPath": "week6.project",
        "description": "week6.project",
        "peekOfCode": "df_encoded = df.copy()\ncategorical_columns = ['Car_Name', 'Fuel_Type', 'Seller_Type', 'Transmission', 'Owner']\nfor col in categorical_columns:\n    df_encoded[col] = le.fit_transform(df_encoded[col])\n# Visa korrelationsmatris\nplt.figure(figsize=(12, 8))\nsns.heatmap(df_encoded.corr(), annot=True, cmap='coolwarm', fmt='.2f')\nplt.title('Correlation Matrix')\nplt.tight_layout()\nplt.show()",
        "detail": "week6.project",
        "documentation": {}
    },
    {
        "label": "categorical_columns",
        "kind": 5,
        "importPath": "week6.project",
        "description": "week6.project",
        "peekOfCode": "categorical_columns = ['Car_Name', 'Fuel_Type', 'Seller_Type', 'Transmission', 'Owner']\nfor col in categorical_columns:\n    df_encoded[col] = le.fit_transform(df_encoded[col])\n# Visa korrelationsmatris\nplt.figure(figsize=(12, 8))\nsns.heatmap(df_encoded.corr(), annot=True, cmap='coolwarm', fmt='.2f')\nplt.title('Correlation Matrix')\nplt.tight_layout()\nplt.show()\n# Skriv ut sammanfattande statistik",
        "detail": "week6.project",
        "documentation": {}
    },
    {
        "label": "numerical_columns",
        "kind": 5,
        "importPath": "week6.project",
        "description": "week6.project",
        "peekOfCode": "numerical_columns = ['Year', 'Selling_Price', 'Kms_Driven']\nfor col in numerical_columns:\n    q1 = df[col].quantile(0.25)\n    q3 = df[col].quantile(0.75)\n    iqr = q3 - q1\n    lower_bound = q1 - 1.5 * iqr\n    upper_bound = q3 + 1.5 * iqr\n    outliers = df[(df[col] < lower_bound) | (df[col] > upper_bound)][col]\n    print(f\"\\nOutliers in {col}:\")\n    print(f\"Number of outliers: {len(outliers)}\")",
        "detail": "week6.project",
        "documentation": {}
    },
    {
        "label": "digits",
        "kind": 5,
        "importPath": "week8.exp.dimReduction",
        "description": "week8.exp.dimReduction",
        "peekOfCode": "digits = load_digits()\nX = digits.data # 64-dimensionellt dataset\ny = digits.target\n# Applicera t-SNE för att reducera dimensionen till 2D\ntsne = TSNE(n_components=2, perplexity=30, learning_rate=200, n_iter=1000, random_state=42)\nX_reduced = tsne.fit_transform(X)\n# Visualisera 2D-projektionen med färg-kodade kluster\nplt.figure(figsize=(12, 8))\nscatter = plt.scatter(X_reduced[:, 0], X_reduced[:, 1], c=y, cmap='Spectral', alpha=0.7)\nplt.colorbar(scatter, label='Digit')",
        "detail": "week8.exp.dimReduction",
        "documentation": {}
    },
    {
        "label": "X",
        "kind": 5,
        "importPath": "week8.exp.dimReduction",
        "description": "week8.exp.dimReduction",
        "peekOfCode": "X = digits.data # 64-dimensionellt dataset\ny = digits.target\n# Applicera t-SNE för att reducera dimensionen till 2D\ntsne = TSNE(n_components=2, perplexity=30, learning_rate=200, n_iter=1000, random_state=42)\nX_reduced = tsne.fit_transform(X)\n# Visualisera 2D-projektionen med färg-kodade kluster\nplt.figure(figsize=(12, 8))\nscatter = plt.scatter(X_reduced[:, 0], X_reduced[:, 1], c=y, cmap='Spectral', alpha=0.7)\nplt.colorbar(scatter, label='Digit')\nplt.title(\"t-SNE Visualization of the MNIST Digits Dataset\")",
        "detail": "week8.exp.dimReduction",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": "week8.exp.dimReduction",
        "description": "week8.exp.dimReduction",
        "peekOfCode": "y = digits.target\n# Applicera t-SNE för att reducera dimensionen till 2D\ntsne = TSNE(n_components=2, perplexity=30, learning_rate=200, n_iter=1000, random_state=42)\nX_reduced = tsne.fit_transform(X)\n# Visualisera 2D-projektionen med färg-kodade kluster\nplt.figure(figsize=(12, 8))\nscatter = plt.scatter(X_reduced[:, 0], X_reduced[:, 1], c=y, cmap='Spectral', alpha=0.7)\nplt.colorbar(scatter, label='Digit')\nplt.title(\"t-SNE Visualization of the MNIST Digits Dataset\")\nplt.xlabel(\"t-SNE Dimension 1\")",
        "detail": "week8.exp.dimReduction",
        "documentation": {}
    },
    {
        "label": "tsne",
        "kind": 5,
        "importPath": "week8.exp.dimReduction",
        "description": "week8.exp.dimReduction",
        "peekOfCode": "tsne = TSNE(n_components=2, perplexity=30, learning_rate=200, n_iter=1000, random_state=42)\nX_reduced = tsne.fit_transform(X)\n# Visualisera 2D-projektionen med färg-kodade kluster\nplt.figure(figsize=(12, 8))\nscatter = plt.scatter(X_reduced[:, 0], X_reduced[:, 1], c=y, cmap='Spectral', alpha=0.7)\nplt.colorbar(scatter, label='Digit')\nplt.title(\"t-SNE Visualization of the MNIST Digits Dataset\")\nplt.xlabel(\"t-SNE Dimension 1\")\nplt.ylabel(\"t-SNE Dimension 2\")\nplt.show()",
        "detail": "week8.exp.dimReduction",
        "documentation": {}
    },
    {
        "label": "X_reduced",
        "kind": 5,
        "importPath": "week8.exp.dimReduction",
        "description": "week8.exp.dimReduction",
        "peekOfCode": "X_reduced = tsne.fit_transform(X)\n# Visualisera 2D-projektionen med färg-kodade kluster\nplt.figure(figsize=(12, 8))\nscatter = plt.scatter(X_reduced[:, 0], X_reduced[:, 1], c=y, cmap='Spectral', alpha=0.7)\nplt.colorbar(scatter, label='Digit')\nplt.title(\"t-SNE Visualization of the MNIST Digits Dataset\")\nplt.xlabel(\"t-SNE Dimension 1\")\nplt.ylabel(\"t-SNE Dimension 2\")\nplt.show()",
        "detail": "week8.exp.dimReduction",
        "documentation": {}
    },
    {
        "label": "scatter",
        "kind": 5,
        "importPath": "week8.exp.dimReduction",
        "description": "week8.exp.dimReduction",
        "peekOfCode": "scatter = plt.scatter(X_reduced[:, 0], X_reduced[:, 1], c=y, cmap='Spectral', alpha=0.7)\nplt.colorbar(scatter, label='Digit')\nplt.title(\"t-SNE Visualization of the MNIST Digits Dataset\")\nplt.xlabel(\"t-SNE Dimension 1\")\nplt.ylabel(\"t-SNE Dimension 2\")\nplt.show()",
        "detail": "week8.exp.dimReduction",
        "documentation": {}
    },
    {
        "label": "X1",
        "kind": 5,
        "importPath": "week8.exp.gmm",
        "description": "week8.exp.gmm",
        "peekOfCode": "X1 = np.random.normal(loc=[5, 5], scale=1.5, size=(100, 2))\nX2 = np.random.normal(loc=[10, 10], scale=1.5, size=(100, 2))\nX3 = np.random.normal(loc=[5, 10], scale=1.5, size=(100, 2))\nX = np.vstack([X1, X2, X3])\n# Applicera GMM med 3 components\ngmm = GaussianMixture(n_components=3, covariance_type='full', random_state=42)\ngmm.fit(X)\nlabels = gmm.predict(X)\nprobs = gmm.predict_proba(X)  # Get cluster membership probabilities\n# Plotta kluster med sannolikheter indikerade med färg-intensitet",
        "detail": "week8.exp.gmm",
        "documentation": {}
    },
    {
        "label": "X2",
        "kind": 5,
        "importPath": "week8.exp.gmm",
        "description": "week8.exp.gmm",
        "peekOfCode": "X2 = np.random.normal(loc=[10, 10], scale=1.5, size=(100, 2))\nX3 = np.random.normal(loc=[5, 10], scale=1.5, size=(100, 2))\nX = np.vstack([X1, X2, X3])\n# Applicera GMM med 3 components\ngmm = GaussianMixture(n_components=3, covariance_type='full', random_state=42)\ngmm.fit(X)\nlabels = gmm.predict(X)\nprobs = gmm.predict_proba(X)  # Get cluster membership probabilities\n# Plotta kluster med sannolikheter indikerade med färg-intensitet\nplt.figure(figsize=(10, 7))",
        "detail": "week8.exp.gmm",
        "documentation": {}
    },
    {
        "label": "X3",
        "kind": 5,
        "importPath": "week8.exp.gmm",
        "description": "week8.exp.gmm",
        "peekOfCode": "X3 = np.random.normal(loc=[5, 10], scale=1.5, size=(100, 2))\nX = np.vstack([X1, X2, X3])\n# Applicera GMM med 3 components\ngmm = GaussianMixture(n_components=3, covariance_type='full', random_state=42)\ngmm.fit(X)\nlabels = gmm.predict(X)\nprobs = gmm.predict_proba(X)  # Get cluster membership probabilities\n# Plotta kluster med sannolikheter indikerade med färg-intensitet\nplt.figure(figsize=(10, 7))\nscatter = plt.scatter(X[:, 0], X[:, 1], c=labels, cmap='viridis', s=30, edgecolor='k', alpha=0.7)",
        "detail": "week8.exp.gmm",
        "documentation": {}
    },
    {
        "label": "X",
        "kind": 5,
        "importPath": "week8.exp.gmm",
        "description": "week8.exp.gmm",
        "peekOfCode": "X = np.vstack([X1, X2, X3])\n# Applicera GMM med 3 components\ngmm = GaussianMixture(n_components=3, covariance_type='full', random_state=42)\ngmm.fit(X)\nlabels = gmm.predict(X)\nprobs = gmm.predict_proba(X)  # Get cluster membership probabilities\n# Plotta kluster med sannolikheter indikerade med färg-intensitet\nplt.figure(figsize=(10, 7))\nscatter = plt.scatter(X[:, 0], X[:, 1], c=labels, cmap='viridis', s=30, edgecolor='k', alpha=0.7)\nplt.colorbar(scatter, label='Cluster')",
        "detail": "week8.exp.gmm",
        "documentation": {}
    },
    {
        "label": "gmm",
        "kind": 5,
        "importPath": "week8.exp.gmm",
        "description": "week8.exp.gmm",
        "peekOfCode": "gmm = GaussianMixture(n_components=3, covariance_type='full', random_state=42)\ngmm.fit(X)\nlabels = gmm.predict(X)\nprobs = gmm.predict_proba(X)  # Get cluster membership probabilities\n# Plotta kluster med sannolikheter indikerade med färg-intensitet\nplt.figure(figsize=(10, 7))\nscatter = plt.scatter(X[:, 0], X[:, 1], c=labels, cmap='viridis', s=30, edgecolor='k', alpha=0.7)\nplt.colorbar(scatter, label='Cluster')\nplt.xlabel('Feature 1')\nplt.ylabel('Feature 2')",
        "detail": "week8.exp.gmm",
        "documentation": {}
    },
    {
        "label": "labels",
        "kind": 5,
        "importPath": "week8.exp.gmm",
        "description": "week8.exp.gmm",
        "peekOfCode": "labels = gmm.predict(X)\nprobs = gmm.predict_proba(X)  # Get cluster membership probabilities\n# Plotta kluster med sannolikheter indikerade med färg-intensitet\nplt.figure(figsize=(10, 7))\nscatter = plt.scatter(X[:, 0], X[:, 1], c=labels, cmap='viridis', s=30, edgecolor='k', alpha=0.7)\nplt.colorbar(scatter, label='Cluster')\nplt.xlabel('Feature 1')\nplt.ylabel('Feature 2')\nplt.title(\"Gaussian Mixture Model Clustering with Soft Labels\")\nplt.show()",
        "detail": "week8.exp.gmm",
        "documentation": {}
    },
    {
        "label": "probs",
        "kind": 5,
        "importPath": "week8.exp.gmm",
        "description": "week8.exp.gmm",
        "peekOfCode": "probs = gmm.predict_proba(X)  # Get cluster membership probabilities\n# Plotta kluster med sannolikheter indikerade med färg-intensitet\nplt.figure(figsize=(10, 7))\nscatter = plt.scatter(X[:, 0], X[:, 1], c=labels, cmap='viridis', s=30, edgecolor='k', alpha=0.7)\nplt.colorbar(scatter, label='Cluster')\nplt.xlabel('Feature 1')\nplt.ylabel('Feature 2')\nplt.title(\"Gaussian Mixture Model Clustering with Soft Labels\")\nplt.show()",
        "detail": "week8.exp.gmm",
        "documentation": {}
    },
    {
        "label": "scatter",
        "kind": 5,
        "importPath": "week8.exp.gmm",
        "description": "week8.exp.gmm",
        "peekOfCode": "scatter = plt.scatter(X[:, 0], X[:, 1], c=labels, cmap='viridis', s=30, edgecolor='k', alpha=0.7)\nplt.colorbar(scatter, label='Cluster')\nplt.xlabel('Feature 1')\nplt.ylabel('Feature 2')\nplt.title(\"Gaussian Mixture Model Clustering with Soft Labels\")\nplt.show()",
        "detail": "week8.exp.gmm",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "week8.exp.marketBasket",
        "description": "week8.exp.marketBasket",
        "peekOfCode": "data = {\n    'transaction_id': [1, 1, 2, 2, 3, 3, 3, 4, 5, 5],\n    'item': ['apple', 'banana', 'apple', 'milk', 'banana', 'milk', 'bread', 'milk', 'apple', 'bread']\n}\ndf = pd.DataFrame(data)\n# Pivot data till one-hot encoded format, varje transaction som en rad, items som kolumner\nbasket = df.pivot_table(index='transaction_id', columns='item', aggfunc=lambda x: 1, fill_value=0)\n# Applicera Apriori för att hitta frequent itemsets med minimum support 0.3\nfrequent_itemsets = apriori(basket, min_support=0.3, use_colnames=True)\nprint(\"Frequent Itemsets:\\n\", frequent_itemsets)",
        "detail": "week8.exp.marketBasket",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "week8.exp.marketBasket",
        "description": "week8.exp.marketBasket",
        "peekOfCode": "df = pd.DataFrame(data)\n# Pivot data till one-hot encoded format, varje transaction som en rad, items som kolumner\nbasket = df.pivot_table(index='transaction_id', columns='item', aggfunc=lambda x: 1, fill_value=0)\n# Applicera Apriori för att hitta frequent itemsets med minimum support 0.3\nfrequent_itemsets = apriori(basket, min_support=0.3, use_colnames=True)\nprint(\"Frequent Itemsets:\\n\", frequent_itemsets)\n# Generera association rules med minimum confidence 0.5\nrules = association_rules(frequent_itemsets, metric=\"confidence\", min_threshold=0.5)\nprint(\"\\nAssociation Rules:\\n\", rules[['antecedents', 'consequents', 'support', 'confidence', 'lift']])",
        "detail": "week8.exp.marketBasket",
        "documentation": {}
    },
    {
        "label": "basket",
        "kind": 5,
        "importPath": "week8.exp.marketBasket",
        "description": "week8.exp.marketBasket",
        "peekOfCode": "basket = df.pivot_table(index='transaction_id', columns='item', aggfunc=lambda x: 1, fill_value=0)\n# Applicera Apriori för att hitta frequent itemsets med minimum support 0.3\nfrequent_itemsets = apriori(basket, min_support=0.3, use_colnames=True)\nprint(\"Frequent Itemsets:\\n\", frequent_itemsets)\n# Generera association rules med minimum confidence 0.5\nrules = association_rules(frequent_itemsets, metric=\"confidence\", min_threshold=0.5)\nprint(\"\\nAssociation Rules:\\n\", rules[['antecedents', 'consequents', 'support', 'confidence', 'lift']])",
        "detail": "week8.exp.marketBasket",
        "documentation": {}
    },
    {
        "label": "frequent_itemsets",
        "kind": 5,
        "importPath": "week8.exp.marketBasket",
        "description": "week8.exp.marketBasket",
        "peekOfCode": "frequent_itemsets = apriori(basket, min_support=0.3, use_colnames=True)\nprint(\"Frequent Itemsets:\\n\", frequent_itemsets)\n# Generera association rules med minimum confidence 0.5\nrules = association_rules(frequent_itemsets, metric=\"confidence\", min_threshold=0.5)\nprint(\"\\nAssociation Rules:\\n\", rules[['antecedents', 'consequents', 'support', 'confidence', 'lift']])",
        "detail": "week8.exp.marketBasket",
        "documentation": {}
    },
    {
        "label": "rules",
        "kind": 5,
        "importPath": "week8.exp.marketBasket",
        "description": "week8.exp.marketBasket",
        "peekOfCode": "rules = association_rules(frequent_itemsets, metric=\"confidence\", min_threshold=0.5)\nprint(\"\\nAssociation Rules:\\n\", rules[['antecedents', 'consequents', 'support', 'confidence', 'lift']])",
        "detail": "week8.exp.marketBasket",
        "documentation": {}
    },
    {
        "label": "ModelManager",
        "kind": 6,
        "importPath": "week8.hierarchicClustering",
        "description": "week8.hierarchicClustering",
        "peekOfCode": "class ModelManager:\n    \"\"\"\n    Klass för att hantera sparning och laddning av olika modelltyper.\n    \"\"\"\n    def __init__(self, base_path: str = \"models\"):\n        self.base_path = base_path\n        os.makedirs(base_path, exist_ok=True)\n    def save_model(self, model: any, model_name: str, model_type: str):\n        \"\"\"\n        Sparar en modell i lämpligt format baserat på typ.",
        "detail": "week8.hierarchicClustering",
        "documentation": {}
    },
    {
        "label": "HierarchicalClusterAnalyzer",
        "kind": 6,
        "importPath": "week8.hierarchicClustering",
        "description": "week8.hierarchicClustering",
        "peekOfCode": "class HierarchicalClusterAnalyzer:\n    \"\"\"\n    Klass för hierarkisk klustringsanalys med olika visualiseringsmetoder.\n    En s.k. \"bottom-up\", eller agglomerativ klustring, där vi utnyttjar en linkage-metod, default är 'Ward's linkage'. Euklidiskt avstånd.\n    \"\"\"\n    def __init__(self):\n        self.linkage_matrix = None\n        self.labels = None\n        self.scaler = StandardScaler()\n    def fit(self, data: np.ndarray, method: str = 'ward', metric: str = 'euclidean'):",
        "detail": "week8.hierarchicClustering",
        "documentation": {}
    },
    {
        "label": "RecommenderSystem",
        "kind": 6,
        "importPath": "week8.hierarchicClustering",
        "description": "week8.hierarchicClustering",
        "peekOfCode": "class RecommenderSystem:\n    \"\"\"\n    Enkel rekommendationsmotor baserad på item-item likhet.\n    Generarar likhetsbaserade item recommendations baserat på en matris av user-item ratings.\n    \"\"\"\n    def __init__(self):\n        self.item_similarity_matrix = None\n        self.items_df = None\n        self.scaler = MinMaxScaler()\n    def fit(self, ratings_matrix: pd.DataFrame):",
        "detail": "week8.hierarchicClustering",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "week8.hierarchicClustering",
        "description": "week8.hierarchicClustering",
        "peekOfCode": "def main():\n    \"\"\"\n    Huvudfunktion som demonstrerar användning av klasserna.\n    \"\"\"\n    # Skapa exempel-data för hierarkisk klustring\n    np.random.seed(42)\n    n_samples = 150\n    # Generera tre distinkta grupper av data\n    group1 = np.random.normal(loc=[0, 0], scale=0.3, size=(n_samples//3, 2))\n    group2 = np.random.normal(loc=[2, 2], scale=0.3, size=(n_samples//3, 2))",
        "detail": "week8.hierarchicClustering",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "week8.hierarchicClustering",
        "description": "week8.hierarchicClustering",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass ModelManager:\n    \"\"\"\n    Klass för att hantera sparning och laddning av olika modelltyper.\n    \"\"\"\n    def __init__(self, base_path: str = \"models\"):\n        self.base_path = base_path\n        os.makedirs(base_path, exist_ok=True)\n    def save_model(self, model: any, model_name: str, model_type: str):\n        \"\"\"",
        "detail": "week8.hierarchicClustering",
        "documentation": {}
    },
    {
        "label": "web_app_sla",
        "kind": 5,
        "importPath": "week8.test",
        "description": "week8.test",
        "peekOfCode": "web_app_sla = 0.9995\nsql_db_sla = 0.9999\nblob_storage_sla = 0.999\nlogic_app_sla = 0.999\n# Calculate the composite SLA by multiplying individual SLAs\ncomposite_sla = web_app_sla * sql_db_sla * blob_storage_sla * logic_app_sla\ncomposite_sla_percentage = composite_sla * 100  # Convert to percentage\nprint(composite_sla_percentage)",
        "detail": "week8.test",
        "documentation": {}
    },
    {
        "label": "sql_db_sla",
        "kind": 5,
        "importPath": "week8.test",
        "description": "week8.test",
        "peekOfCode": "sql_db_sla = 0.9999\nblob_storage_sla = 0.999\nlogic_app_sla = 0.999\n# Calculate the composite SLA by multiplying individual SLAs\ncomposite_sla = web_app_sla * sql_db_sla * blob_storage_sla * logic_app_sla\ncomposite_sla_percentage = composite_sla * 100  # Convert to percentage\nprint(composite_sla_percentage)",
        "detail": "week8.test",
        "documentation": {}
    },
    {
        "label": "blob_storage_sla",
        "kind": 5,
        "importPath": "week8.test",
        "description": "week8.test",
        "peekOfCode": "blob_storage_sla = 0.999\nlogic_app_sla = 0.999\n# Calculate the composite SLA by multiplying individual SLAs\ncomposite_sla = web_app_sla * sql_db_sla * blob_storage_sla * logic_app_sla\ncomposite_sla_percentage = composite_sla * 100  # Convert to percentage\nprint(composite_sla_percentage)",
        "detail": "week8.test",
        "documentation": {}
    },
    {
        "label": "logic_app_sla",
        "kind": 5,
        "importPath": "week8.test",
        "description": "week8.test",
        "peekOfCode": "logic_app_sla = 0.999\n# Calculate the composite SLA by multiplying individual SLAs\ncomposite_sla = web_app_sla * sql_db_sla * blob_storage_sla * logic_app_sla\ncomposite_sla_percentage = composite_sla * 100  # Convert to percentage\nprint(composite_sla_percentage)",
        "detail": "week8.test",
        "documentation": {}
    },
    {
        "label": "composite_sla",
        "kind": 5,
        "importPath": "week8.test",
        "description": "week8.test",
        "peekOfCode": "composite_sla = web_app_sla * sql_db_sla * blob_storage_sla * logic_app_sla\ncomposite_sla_percentage = composite_sla * 100  # Convert to percentage\nprint(composite_sla_percentage)",
        "detail": "week8.test",
        "documentation": {}
    },
    {
        "label": "composite_sla_percentage",
        "kind": 5,
        "importPath": "week8.test",
        "description": "week8.test",
        "peekOfCode": "composite_sla_percentage = composite_sla * 100  # Convert to percentage\nprint(composite_sla_percentage)",
        "detail": "week8.test",
        "documentation": {}
    },
    {
        "label": "DataPreprocessor",
        "kind": 6,
        "importPath": "week8.unsupervisedAI",
        "description": "week8.unsupervisedAI",
        "peekOfCode": "class DataPreprocessor:\n    def __init__(self):\n        self.scaler = StandardScaler()\n        self.pca = None\n    def prepare_data(self, data: pd.DataFrame) -> np.ndarray:\n        '''\n        Förbereder data genom att hantera saknade värden och standardisera\n        '''\n        # Saknde värden\n        data_cleaned = data.fillna(data.mean())",
        "detail": "week8.unsupervisedAI",
        "documentation": {}
    },
    {
        "label": "KMeansAnalyzer",
        "kind": 6,
        "importPath": "week8.unsupervisedAI",
        "description": "week8.unsupervisedAI",
        "peekOfCode": "class KMeansAnalyzer:\n    '''\n    Klass för att utföra K-means clustering och analysera resultat\n    K-means antar att att kluster är sfäriska och har ungefär samma densitet (kompakthet) och varians.\n    Särskilt bra om vi vet det förvaften antalet kluster.\n    Försöker minimera summan av kvadrerade avstånd (sum of squared distances) inom varje kluster.\n    Hanterar komplexa och oregelbundna klusterformer mindre bra.\n    Hanterar outliers mindre bra, leder till oregelbundna klusterformer och sãoligt positionerade centroider.\n    Eftersom K-means kräver att vi vet antalet kluster vi vill dela upp datapunkterna i, försöker vi först hitta ett optimalt antal kluster.\n    '''",
        "detail": "week8.unsupervisedAI",
        "documentation": {}
    },
    {
        "label": "DBSCANAnalyzer",
        "kind": 6,
        "importPath": "week8.unsupervisedAI",
        "description": "week8.unsupervisedAI",
        "peekOfCode": "class DBSCANAnalyzer:\n    '''\n    Klass för att utföra DBSCAN för oregelbundna former (Density-Based Spatial Clustering of Applications with Noise).\n    Bra för kuster som inte nödvändigtvis är sfäriskt formade.\n    Hittar kluster baserat på densitet, identifierar punkter som har ett minimalt antal grann-punkter (neighboring points)\n    inom ett specificerat avstånd (epsilon).\n    DBSCAN behöver inte veta antalet kluster, men kräver paremeters eps (epsilon) och min_samples (minsta antalet punkter i ett \"neighborhood\" för att skapa en \"dense region\").\n    DBSCAN kan identifiera \"noise points\", punkter som inte tillhör något kluster. Hanterarält outlier bättre föran K-means.\n    '''\n    def __init__(self):",
        "detail": "week8.unsupervisedAI",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "week8.unsupervisedAI",
        "description": "week8.unsupervisedAI",
        "peekOfCode": "def main():\n    '''\n    Huvudfunktion\n    '''\n    # Skapar syntetisk data för demo\n    np.random.seed(42)\n    # Generera tre kluster med olika former\n    n_samples = 300\n    # Första kluster: cirkulärt\n    cluster1 = np.random.normal(loc=[2, 2], scale=0.5, size=(n_samples//3, 2))",
        "detail": "week8.unsupervisedAI",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "week8.unsupervisedAI",
        "description": "week8.unsupervisedAI",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass DataPreprocessor:\n    def __init__(self):\n        self.scaler = StandardScaler()\n        self.pca = None\n    def prepare_data(self, data: pd.DataFrame) -> np.ndarray:\n        '''\n        Förbereder data genom att hantera saknade värden och standardisera\n        '''\n        # Saknde värden",
        "detail": "week8.unsupervisedAI",
        "documentation": {}
    }
]